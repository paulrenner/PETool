<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PE Fund Manager</title>
    <style>
        /* ===========================
           CSS Variables
           =========================== */
        :root {
            /* Primary Colors */
            --color-primary: #2C3E50;
            --color-primary-light: #34495E;
            --color-background: #ECF0F1;
            --color-white: #ffffff;

            /* Action Colors */
            --color-action: #3498DB;
            --color-action-hover: #2980B9;
            --color-success: #27AE60;
            --color-success-hover: #229954;
            --color-danger: #E74C3C;
            --color-danger-hover: #C0392B;
            --color-secondary: #95A5A6;
            --color-secondary-hover: #7F8C8D;

            /* Neutral Colors */
            --color-text: #2C3E50;
            --color-text-light: #95A5A6;
            --color-border: #E0E0E0;
            --color-border-input: #BDC3C7;
            --color-hover-bg: #F8F9FA;
            --color-alt-bg: #FAFAFA;

            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 12px;
            --spacing-lg: 20px;
            --spacing-xl: 30px;

            /* Border Radius */
            --radius-sm: 3px;
            --radius-md: 4px;

            /* Shadows */
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0 4px 12px rgba(0, 0, 0, 0.15);

            /* Transitions */
            --transition-fast: all 0.15s ease;
            --transition-medium: all 0.2s ease;
        }

        /* Dark Mode Theme - Improved contrast for WCAG AA compliance */
        [data-theme="dark"] {
            --color-primary: #F0F0F0;
            --color-primary-light: #2D3748;
            --color-background: #1A202C;
            --color-white: #2D3748;

            --color-action: #63B3ED;
            --color-action-hover: #4299E1;
            --color-success: #68D391;
            --color-success-hover: #48BB78;
            --color-danger: #FC8181;
            --color-danger-hover: #F56565;
            --color-secondary: #A0AEC0;
            --color-secondary-hover: #CBD5E0;

            --color-text: #F7FAFC;
            --color-text-light: #CBD5E0;
            --color-border: #4A5568;
            --color-border-input: #4A5568;
            --color-hover-bg: #374151;
            --color-alt-bg: #1F2937;

            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        [data-theme="dark"] header {
            background: #1F2937;
            border-bottom-color: #374151;
            color: #E2E8F0;
        }

        [data-theme="dark"] header h1 {
            color: #F7FAFC;
        }

        [data-theme="dark"] thead {
            background: #374151;
        }

        [data-theme="dark"] thead th {
            color: #F7FAFC;
        }

        [data-theme="dark"] th:hover {
            background: #4A5568;
        }

        [data-theme="dark"] td {
            border-bottom-color: #374151;
        }

        [data-theme="dark"] tbody tr:last-child {
            border-color: #4A5568;
            background: #1F2937;
        }

        [data-theme="dark"] .modal-content {
            background: #2D3748;
        }

        [data-theme="dark"] .sidebar {
            background: #2D3748;
        }

        [data-theme="dark"] .sidebar-header {
            background: #1F2937;
            border-bottom-color: #4A5568;
        }

        [data-theme="dark"] .status-message {
            background: #2D3748;
        }

        [data-theme="dark"] .table-tag {
            background: #374151;
            color: #E2E8F0;
        }

        [data-theme="dark"] .tag {
            background: #4299E1;
        }

        [data-theme="dark"] input:disabled,
        [data-theme="dark"] textarea:disabled,
        [data-theme="dark"] select:disabled {
            background: #1F2937;
        }

        [data-theme="dark"] .details-table th {
            background-color: #374151;
            border-color: #4A5568;
        }

        [data-theme="dark"] .details-table td {
            border-color: #4A5568;
        }

        [data-theme="dark"] .details-table tbody tr:nth-child(even) {
            background-color: #1F2937;
        }

        [data-theme="dark"] .group-item,
        [data-theme="dark"] .fund-name-item {
            background: #1F2937;
            border-color: #4A5568;
        }

        [data-theme="dark"] .action-dropdown {
            background: #2D3748;
            border-color: #4A5568;
        }

        [data-theme="dark"] .action-dropdown a:hover {
            background: #374151;
        }

        [data-theme="dark"] .action-dropdown a.danger-action:hover {
            background: #742A2A;
        }

        [data-theme="dark"] .loading-content {
            background: #2D3748;
        }

        /* Portfolio Summary Stats */
        .portfolio-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            padding: 16px 20px;
            background: var(--color-alt-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            margin-bottom: 20px;
        }

        .summary-stat {
            display: flex;
            flex-direction: column;
            min-width: 100px;
            padding: 8px 16px;
            background: var(--color-white);
            border-radius: var(--radius-sm);
            border: 1px solid var(--color-border);
        }

        .summary-label {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--color-text-light);
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .summary-value {
            font-size: 18px;
            font-weight: 600;
            color: var(--color-text);
            font-variant-numeric: tabular-nums;
        }

        .summary-value.positive {
            color: var(--color-success);
        }

        .summary-value.negative {
            color: var(--color-danger);
        }

        /* Metric Info Tooltips */
        .summary-label-container {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--color-text-light);
            color: var(--color-white);
            font-size: 9px;
            font-weight: 700;
            cursor: help;
            position: relative;
            flex-shrink: 0;
        }

        .info-icon:hover {
            background: var(--color-action);
        }

        .info-icon .tooltip {
            display: none;
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--color-primary);
            color: white;
            padding: 8px 12px;
            border-radius: var(--radius-md);
            font-size: 12px;
            font-weight: 400;
            white-space: normal;
            width: 220px;
            text-align: left;
            z-index: 1000;
            box-shadow: var(--shadow-md);
            line-height: 1.4;
        }

        .info-icon .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--color-primary);
        }

        .info-icon:hover .tooltip {
            display: block;
        }

        [data-theme="dark"] .info-icon {
            background: var(--color-text-light);
            color: var(--color-background);
        }

        [data-theme="dark"] .info-icon .tooltip {
            background: #4A5568;
        }

        [data-theme="dark"] .info-icon .tooltip::after {
            border-top-color: #4A5568;
        }

        /* Cash Flow Timeline Panel */
        .timeline-panel {
            background: var(--color-white);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--color-alt-bg);
            border-bottom: 1px solid var(--color-border);
            cursor: pointer;
            user-select: none;
        }

        .timeline-header:hover {
            background: var(--color-hover-bg);
        }

        .timeline-header h3 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--color-text);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timeline-toggle {
            font-size: 12px;
            color: var(--color-text-light);
            transition: transform 0.2s ease;
        }

        .timeline-panel.expanded .timeline-toggle {
            transform: rotate(180deg);
        }

        .timeline-content {
            display: none;
            padding: 16px;
            overflow-x: auto;
        }

        .timeline-panel.expanded .timeline-content {
            display: block;
        }

        .timeline-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            min-width: 600px;
        }

        .timeline-table th,
        .timeline-table td {
            padding: 8px 12px;
            text-align: right;
            border: 1px solid var(--color-border);
            white-space: nowrap;
        }

        .timeline-table th {
            background: var(--color-alt-bg);
            font-weight: 600;
            color: var(--color-text);
        }

        .timeline-table th:first-child,
        .timeline-table td:first-child {
            text-align: left;
            position: sticky;
            left: 0;
            background: var(--color-white);
            z-index: 1;
        }

        .timeline-table th:first-child {
            background: var(--color-alt-bg);
        }

        .timeline-table .year-projected {
            background: var(--color-alt-bg);
            font-style: italic;
        }

        .timeline-table .year-projected th {
            background: #E8F4FD;
        }

        [data-theme="dark"] .timeline-table .year-projected th {
            background: #2C4A5E;
        }

        .timeline-table .row-calls td {
            color: var(--color-danger);
        }

        .timeline-table .row-distributions td {
            color: var(--color-success);
        }

        .timeline-table .row-net td.positive {
            color: var(--color-success);
        }

        .timeline-table .row-net td.negative {
            color: var(--color-danger);
        }

        .timeline-table .row-net {
            font-weight: 600;
            border-top: 2px solid var(--color-border);
        }

        .timeline-table .row-label {
            font-weight: 500;
            color: var(--color-text);
        }

        .timeline-table td:first-child {
            font-weight: 500;
        }

        .timeline-divider {
            border-left: 3px solid var(--color-action) !important;
        }

        .timeline-expand-row {
            cursor: pointer;
        }

        .timeline-expand-row:hover {
            background: var(--color-hover-bg);
        }

        .timeline-expand-icon {
            display: inline-block;
            width: 16px;
            font-size: 10px;
            color: var(--color-text-light);
        }

        .timeline-fund-row {
            display: none;
        }

        .timeline-fund-row.visible {
            display: table-row;
        }

        .timeline-fund-row td {
            background: var(--color-alt-bg);
            font-size: 12px;
        }

        .timeline-fund-row td:first-child {
            padding-left: 28px;
            background: var(--color-alt-bg);
        }

        .timeline-no-data {
            text-align: center;
            padding: 30px;
            color: var(--color-text-light);
            font-style: italic;
        }

        @media (max-width: 768px) {
            .timeline-table {
                font-size: 11px;
            }

            .timeline-table th,
            .timeline-table td {
                padding: 6px 8px;
            }
        }

        /* Keyboard Shortcuts Modal */
        .shortcuts-modal .modal-content {
            max-width: 500px;
        }

        .shortcuts-list {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px 20px;
            margin-top: 16px;
        }

        .shortcut-key {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .shortcut-key kbd {
            display: inline-block;
            padding: 4px 8px;
            font-family: monospace;
            font-size: 12px;
            background: var(--color-alt-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .shortcut-desc {
            color: var(--color-text);
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .portfolio-summary {
                gap: 8px;
                padding: 12px;
            }

            .summary-stat {
                min-width: 80px;
                padding: 6px 10px;
            }

            .summary-label {
                font-size: 10px;
            }

            .summary-value {
                font-size: 14px;
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--color-background);
            min-height: 100vh;
            padding: var(--spacing-lg);
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: var(--color-white);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
        }

        header {
            background: var(--color-primary);
            color: var(--color-white);
            padding: 24px var(--spacing-xl);
            border-bottom: 1px solid var(--color-primary-light);
        }

        header h1 {
            font-size: 1.75em;
            font-weight: 600;
            margin-bottom: 4px;
            letter-spacing: -0.5px;
        }

        header p {
            font-size: 0.95em;
            opacity: 0.85;
            font-weight: 400;
        }

        .controls-bar {
            background: var(--color-alt-bg);
            padding: var(--spacing-lg) var(--spacing-xl);
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            align-items: flex-end;
            border-bottom: 1px solid var(--color-border);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-group label {
            font-weight: 500;
            font-size: 0.85em;
            color: var(--color-text);
        }

        .control-group select,
        .control-group input[type="date"],
        .control-group input[type="text"] {
            padding: var(--spacing-sm) var(--spacing-md);
            border: 1px solid var(--color-border-input);
            border-radius: var(--radius-sm);
            font-size: 14px;
            min-width: 150px;
            background: var(--color-white);
            color: var(--color-text);
        }

        .control-group select:focus,
        .control-group input[type="date"]:focus,
        .control-group input[type="text"]:focus {
            outline: none;
            border-color: var(--color-action);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
        }

        /* Filter Badge */
        .filter-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: var(--color-action);
            color: white;
            font-size: 11px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 12px;
            margin-left: 8px;
            white-space: nowrap;
        }

        .filter-badge .clear-filters {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 10px;
            cursor: pointer;
            border: none;
            padding: 0;
            line-height: 1;
        }

        .filter-badge .clear-filters:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        button {
            padding: 9px 18px;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .controls-bar button {
            margin-top: auto;
        }

        .btn-primary {
            background: var(--color-action);
            color: var(--color-white);
        }

        .btn-primary:hover {
            background: var(--color-action-hover);
        }

        .btn-secondary {
            background: var(--color-secondary);
            color: var(--color-white);
        }

        .btn-secondary:hover {
            background: var(--color-secondary-hover);
        }

        .btn-success {
            background: var(--color-success);
            color: var(--color-white);
        }

        .btn-success:hover {
            background: var(--color-success-hover);
        }

        .btn-danger {
            background: var(--color-danger);
            color: var(--color-white);
        }

        .btn-danger:hover {
            background: var(--color-danger-hover);
        }

        .btn-link {
            background: none;
            border: none;
            color: var(--color-action);
            cursor: pointer;
            padding: 2px 4px;
            font-size: inherit;
            text-decoration: underline;
        }

        .btn-link:hover {
            color: var(--color-action-hover);
        }

        .btn-info {
            background: var(--color-primary-light);
            color: var(--color-white);
        }

        .btn-info:hover {
            background: var(--color-primary);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Focus indicators for accessibility - visible focus ring for keyboard navigation */
        button:focus-visible,
        a:focus-visible,
        input:focus-visible,
        select:focus-visible,
        textarea:focus-visible {
            outline: 2px solid var(--color-action);
            outline-offset: 2px;
        }

        /* Remove default outline but keep focus-visible */
        button:focus:not(:focus-visible),
        a:focus:not(:focus-visible),
        input:focus:not(:focus-visible),
        select:focus:not(:focus-visible) {
            outline: none;
        }

        /* Skip to main content link for screen readers */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--color-action);
            color: white;
            padding: 8px;
            z-index: 100000;
            transition: top 0.3s;
        }

        .skip-link:focus {
            top: 0;
        }

        /* Announce live regions for screen readers */
        .sr-announce {
            position: absolute;
            left: -10000px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        /* Loading indicator for filter operations */
        .filter-loading {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            color: var(--color-text-light);
            font-size: 13px;
        }

        .filter-loading.show {
            display: flex;
        }

        .filter-loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--color-border);
            border-top-color: var(--color-action);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Table row keyboard focus */
        tbody tr:focus {
            outline: 2px solid var(--color-action);
            outline-offset: -2px;
        }

        tbody tr[tabindex]:hover {
            background: var(--color-hover-bg);
        }

        .btn-icon {
            background: none;
            border: none;
            color: var(--color-text-light);
            font-size: 16px;
            padding: var(--spacing-xs) var(--spacing-sm);
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .btn-icon:hover {
            color: var(--color-primary-light);
        }

        /* Action Dropdown */
        .action-dropdown {
            display: none;
            position: fixed;
            background: var(--color-white);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            min-width: 160px;
            z-index: 10000;
            padding: var(--spacing-xs) 0;
        }

        .action-dropdown.show {
            display: block;
        }

        .action-dropdown a {
            display: block;
            padding: 10px 16px;
            color: var(--color-text);
            text-decoration: none;
            font-size: 14px;
            transition: var(--transition-fast);
        }

        .action-dropdown a:hover {
            background: var(--color-hover-bg);
        }

        .action-dropdown a.danger-action {
            color: var(--color-danger);
        }

        .action-dropdown a.danger-action:hover {
            background: #FFEBEE;
        }

        /* Dropdown Menu */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--color-white);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-md);
            min-width: 160px;
            z-index: 1000;
            margin-top: var(--spacing-xs);
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-menu a {
            display: block;
            padding: 10px 16px;
            color: var(--color-text);
            text-decoration: none;
            font-size: 14px;
            transition: var(--transition-fast);
        }

        .dropdown-menu a:hover {
            background: var(--color-hover-bg);
        }

        .dropdown-menu a:first-child {
            border-radius: var(--radius-sm) var(--radius-sm) 0 0;
        }

        .dropdown-menu a:last-child {
            border-radius: 0 0 var(--radius-sm) var(--radius-sm);
        }

        .content {
            padding: var(--spacing-xl);
        }

        .table-container {
            overflow-x: auto;
            margin-bottom: var(--spacing-xl);
        }

        /* Consolidated table styles - removed duplicate definition */
        .table-container table,
        table {
            width: 100%;
            border-collapse: collapse;
            background: var(--color-white);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            overflow: hidden;
        }

        .table-container table {
            width: 100%;
            table-layout: auto;
        }

        thead {
            background: var(--color-primary-light);
            color: var(--color-white);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th {
            padding: 14px var(--spacing-md);
            text-align: left;
            font-weight: 500;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
            font-size: 0.9em;
        }

        th:hover {
            background: var(--color-primary);
        }

        th.sorted-asc::after {
            content: ' ↑';
            opacity: 1;
        }

        th.sorted-desc::after {
            content: ' ↓';
            opacity: 1;
        }

        /* Multi-column sort priority indicators */
        th.sorted-asc[data-sort-priority="1"]::after { content: ' ↑¹'; }
        th.sorted-asc[data-sort-priority="2"]::after { content: ' ↑²'; }
        th.sorted-asc[data-sort-priority="3"]::after { content: ' ↑³'; }
        th.sorted-asc[data-sort-priority="4"]::after { content: ' ↑⁴'; }
        th.sorted-asc[data-sort-priority="5"]::after { content: ' ↑⁵'; }
        th.sorted-desc[data-sort-priority="1"]::after { content: ' ↓¹'; }
        th.sorted-desc[data-sort-priority="2"]::after { content: ' ↓²'; }
        th.sorted-desc[data-sort-priority="3"]::after { content: ' ↓³'; }
        th.sorted-desc[data-sort-priority="4"]::after { content: ' ↓⁴'; }
        th.sorted-desc[data-sort-priority="5"]::after { content: ' ↓⁵'; }

        th.wrap-header {
            white-space: normal;
            line-height: 1.3;
            padding: 10px 8px;
        }

        /* Resizable columns */
        th {
            position: relative;
        }

        th.resizable {
            overflow: hidden;
            text-overflow: ellipsis;
        }

        th .resizer {
            position: absolute;
            top: 0;
            right: -8px;
            width: 16px;
            height: 100%;
            cursor: col-resize;
            user-select: none;
            z-index: 10;
        }

        th .resizer:hover {
            background-color: var(--color-action);
            width: 4px;
            right: 0;
        }

        th.resizing {
            user-select: none;
        }

        /* Parent/Account column with max-width */
        #fundsTable th:nth-child(2),
        #fundsTable td:nth-child(2) {
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #F0F0F0;
            font-size: 0.9em;
            color: var(--color-primary);
        }

        tbody tr:hover {
            background: var(--color-hover-bg);
        }

        tbody tr:last-child {
            border-top: 2px solid var(--color-primary-light);
            border-bottom: 2px solid var(--color-primary-light);
            font-weight: 600;
            background: var(--color-alt-bg);
        }

        tbody tr:last-child td {
            border-bottom: none;
        }

        td.number {
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        th.center,
        td.center {
            text-align: center;
        }

        .positive {
            color: var(--color-success);
        }

        .negative {
            color: var(--color-danger);
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--color-text-light);
        }

        .action-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: nowrap;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
            min-width: auto;
            white-space: nowrap;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal.show {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 40px 20px;
        }

        .modal-content {
            background-color: var(--color-white);
            padding: 30px;
            border-radius: var(--radius-md);
            width: 100%;
            max-width: 700px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            position: relative;
            margin: auto;
        }

        .modal-content h2 {
            margin-bottom: 24px;
            color: var(--color-primary);
            font-size: 1.5em;
            font-weight: 600;
        }

        .modal .close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 28px;
            font-weight: 300;
            color: var(--color-text-light);
            cursor: pointer;
            line-height: 1;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            transition: var(--transition-medium);
        }

        .modal .close:hover {
            background: var(--color-border);
            color: var(--color-primary);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--color-primary);
            font-size: 0.9em;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--color-border-input);
            border-radius: var(--radius-sm);
            font-size: 14px;
            transition: var(--transition-fast);
            background: var(--color-white);
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--color-action);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
        }

        .form-group.has-error input,
        .form-group.has-error select,
        .form-group.has-error textarea {
            border-color: var(--color-danger);
            background-color: rgba(231, 76, 60, 0.05);
        }

        .form-group.has-error input:focus,
        .form-group.has-error select:focus,
        .form-group.has-error textarea:focus {
            border-color: var(--color-danger);
            box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.1);
        }

        .form-group textarea {
            font-family: 'Courier New', monospace;
            resize: vertical;
            min-height: 100px;
        }

        .form-group .hint {
            font-size: 12px;
            color: var(--color-secondary-hover);
            margin-top: 5px;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
            min-height: 24px;
        }

        .tag {
            display: inline-flex;
            align-items: center;
            background: var(--color-action);
            color: var(--color-white);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
            gap: 6px;
        }

        .tag-remove {
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            line-height: 1;
            opacity: 0.8;
        }

        .tag-remove:hover {
            opacity: 1;
        }

        .table-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .table-tag {
            display: inline-block;
            background: #E8F4F8;
            color: var(--color-primary);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
        }

        .form-actions {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }

        .form-actions button {
            flex: 1;
        }

        .status-message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 14px 45px 14px 20px;
            border-radius: var(--radius-sm);
            background: var(--color-white);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 2000;
            animation: slideIn 0.2s ease;
            max-width: 400px;
            border-left: 3px solid;
        }

        .status-message.success {
            border-left-color: var(--color-success);
        }

        .status-message.error {
            border-left-color: var(--color-danger);
        }

        .status-message.warning {
            border-left-color: #F39C12;
        }

        .status-message .close-status {
            position: absolute;
            top: 10px;
            right: 12px;
            font-size: 20px;
            font-weight: 300;
            color: var(--color-text-light);
            cursor: pointer;
            line-height: 1;
            background: none;
            border: none;
            padding: 0;
        }

        .status-message .close-status:hover {
            color: var(--color-primary);
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-content {
            background: var(--color-white);
            padding: 30px 40px;
            border-radius: 5px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--color-action);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--color-primary);
            font-size: 16px;
            font-weight: 500;
        }

        input[type="file"] {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            padding: 9px 18px;
            background: var(--color-primary-light);
            color: var(--color-white);
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition-fast);
            font-size: 14px;
        }

        .file-input-label:hover {
            background: var(--color-primary);
        }

        input:disabled,
        textarea:disabled,
        select:disabled {
            opacity: 0.6;
            background: #F5F5F5;
            cursor: not-allowed;
        }

        /* Details Table */
        .details-table-wrapper {
            overflow-x: auto;
            margin-top: 15px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            max-width: 100%;
        }

        .details-table {
            border-collapse: collapse;
            font-size: 0.85em;
        }

        .details-table th {
            background-color: var(--color-primary-light);
            color: var(--color-white);
            padding: 6px 8px;
            text-align: left;
            border: 1px solid var(--color-primary);
            font-weight: 500;
            font-size: 0.85em;
        }

        .details-table td {
            padding: 4px;
            border: 1px solid var(--color-border);
        }

        .details-table tbody tr:nth-child(even) {
            background-color: var(--color-alt-bg);
        }

        .details-table input,
        .details-table select {
            padding: 6px 8px;
            border: 1px solid var(--color-border-input);
            border-radius: var(--radius-sm);
            font-size: 1em;
            box-sizing: border-box;
        }

        .details-table input[type="number"],
        .details-table input[type="text"] {
            text-align: right;
            width: 90px;
        }

        .details-table input[type="date"] {
            text-align: left;
            width: 130px;
        }

        .details-table select {
            text-align: left;
            width: 115px;
        }

        .details-table input[type="checkbox"] {
            width: auto;
        }

        /* Cash Flows Table Column Widths */
        #cashFlowsTable {
            width: 100%;
        }

        #cashFlowsTable th:nth-child(1),
        #cashFlowsTable td:nth-child(1) {
            width: 150px;
        }

        #cashFlowsTable th:nth-child(2),
        #cashFlowsTable td:nth-child(2) {
            width: 140px;
        }

        #cashFlowsTable th:nth-child(3),
        #cashFlowsTable td:nth-child(3) {
            width: 130px;
        }

        #cashFlowsTable th:nth-child(4),
        #cashFlowsTable td:nth-child(4) {
            width: 160px;
            text-align: center;
        }

        #cashFlowsTable th:nth-child(5),
        #cashFlowsTable td:nth-child(5) {
            width: auto;
            text-align: right;
        }

        /* NAV Table Column Widths */
        #navTable {
            width: 100%;
        }

        #navTable th:nth-child(1),
        #navTable td:nth-child(1) {
            width: 150px;
        }

        #navTable th:nth-child(2),
        #navTable td:nth-child(2) {
            width: 140px;
        }

        #navTable th:nth-child(3),
        #navTable td:nth-child(3) {
            width: auto;
            text-align: right;
        }

        .delete-row-btn {
            background: none;
            border: none;
            color: var(--color-danger);
            font-size: 18px;
            padding: 4px 8px;
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .delete-row-btn:hover {
            color: var(--color-danger-hover);
        }

        .validation-error-row {
            background-color: #ffebee !important;
            border-left: 3px solid var(--color-danger);
        }

        .validation-error-row input {
            border-color: var(--color-danger) !important;
        }

        #manageFundNamesModal .fund-name-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: var(--color-alt-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            gap: 10px;
        }

        #manageFundNamesModal .fund-name-item .btn-sm {
            margin-left: 5px;
        }

        /* Manage Groups Modal */
        .group-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 4px;
            background: var(--color-alt-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
        }

        .group-item.level-0 {
            margin-left: 0;
            font-weight: 600;
        }

        .group-item.level-1 {
            margin-left: 20px;
            font-weight: 500;
        }

        .group-item.level-2 {
            margin-left: 40px;
        }

        .group-item.level-3 {
            margin-left: 60px;
        }

        .group-item-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .group-item-type {
            font-size: 0.85em;
            color: var(--color-secondary-hover);
            font-style: italic;
        }

        .group-item-actions {
            display: flex;
            gap: 5px;
        }

        @media (max-width: 1400px) {
            .controls-bar {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                width: 100%;
            }
        }

        /* Mobile responsive improvements */
        @media (max-width: 768px) {
            body {
                padding: var(--spacing-sm);
            }

            header {
                padding: 16px var(--spacing-md);
            }

            header h1 {
                font-size: 1.4em;
            }

            .controls-bar {
                padding: var(--spacing-md);
                gap: 12px;
            }

            .content {
                padding: var(--spacing-md);
            }

            /* Make table scrollable horizontally on mobile */
            .table-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Adjust modal for mobile */
            .modal-content {
                padding: 20px;
                margin: 20px;
                max-width: calc(100% - 40px);
            }

            /* Stack form actions vertically on mobile */
            .form-actions {
                flex-direction: column;
            }

            .form-actions button {
                width: 100%;
            }

            /* Adjust sidebar for mobile */
            .sidebar {
                width: 280px;
                right: -280px;
            }

            /* Smaller buttons on mobile */
            .btn-icon {
                font-size: 18px !important;
                padding: 6px;
            }

            /* Adjust table font sizes for mobile */
            th, td {
                font-size: 0.85em;
                padding: 8px 6px;
            }
        }

        /* Very small screens */
        @media (max-width: 480px) {
            header h1 {
                font-size: 1.2em;
            }

            header p {
                font-size: 0.85em;
            }

            .controls-bar {
                gap: 8px;
            }

            .modal-content {
                padding: 15px;
            }

            .modal-content h2 {
                font-size: 1.2em;
            }

            th, td {
                font-size: 0.8em;
                padding: 6px 4px;
            }

            /* Only enforce min-width on extremely narrow screens */
            .table-container table {
                min-width: 800px;
            }
        }

        /* Print Styles for PDF Export */
        @media print {
            body {
                background: var(--color-white);
                padding: 0;
            }

            .container {
                box-shadow: none;
                border-radius: 0;
            }

            .controls-bar,
            .btn-sm,
            button {
                display: none !important;
            }

            header {
                background: var(--color-white);
                color: var(--color-primary);
                border-bottom: 2px solid var(--color-primary);
                padding: 15px;
            }

            .content {
                padding: 10px;
            }

            table {
                width: 100%;
                max-width: 100%;
                page-break-inside: auto;
                border: 1px solid var(--color-primary);
                table-layout: fixed;
            }

            /* Override min-width for main table in print view */
            .table-container table {
                min-width: 100% !important;
                max-width: 100% !important;
            }

            thead {
                background: var(--color-primary) !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            tr {
                page-break-inside: avoid;
                page-break-after: auto;
            }

            th, td {
                padding: 8px 6px;
                font-size: 10px;
            }

            /* Reset inline styles and set specific widths for print to fit landscape page */
            #fundsTable th,
            #fundsTable td {
                min-width: auto !important;
                max-width: none !important;
            }

            /* Fund Name - allow it to be wider */
            #fundsTable th:nth-child(1),
            #fundsTable td:nth-child(1) {
                width: 130px !important;
            }

            /* Investor - limit width to fit page */
            #fundsTable th:nth-child(2),
            #fundsTable td:nth-child(2) {
                width: 90px !important;
                max-width: 90px !important;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            /* Vintage */
            #fundsTable th:nth-child(3),
            #fundsTable td:nth-child(3) {
                width: 45px !important;
            }

            /* Numeric columns - compact width */
            #fundsTable th:nth-child(4),
            #fundsTable td:nth-child(4),
            #fundsTable th:nth-child(5),
            #fundsTable td:nth-child(5),
            #fundsTable th:nth-child(6),
            #fundsTable td:nth-child(6),
            #fundsTable th:nth-child(7),
            #fundsTable td:nth-child(7),
            #fundsTable th:nth-child(8),
            #fundsTable td:nth-child(8),
            #fundsTable th:nth-child(11),
            #fundsTable td:nth-child(11) {
                width: 70px !important;
            }

            /* MOIC and IRR - narrower */
            #fundsTable th:nth-child(9),
            #fundsTable td:nth-child(9),
            #fundsTable th:nth-child(10),
            #fundsTable td:nth-child(10) {
                width: 50px !important;
            }

            /* Hide Actions column in print view */
            thead tr th:last-child,
            tbody tr td:last-child {
                display: none;
            }

            tbody tr:last-child {
                border-top: 2px solid var(--color-primary);
                border-bottom: 2px solid var(--color-primary);
                background: #F0F0F0 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .positive {
                color: var(--color-success) !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .negative {
                color: var(--color-danger) !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            @page {
                size: landscape;
                margin: 0.5in;
            }

            /* Hide minimized timeline in print view */
            #timelinePanel:not(.expanded) {
                display: none !important;
            }
        }

        /* Sidebar Styles */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .sidebar-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .sidebar {
            position: fixed;
            top: 0;
            right: -320px;
            width: 320px;
            height: 100%;
            background: var(--color-white);
            box-shadow: -2px 0 8px rgba(0, 0, 0, 0.15);
            z-index: 9999;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .sidebar.show {
            right: 0;
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--color-border);
            background: var(--color-hover-bg);
        }

        .sidebar-header h3 {
            margin: 0;
            color: var(--color-primary);
            font-size: 18px;
            font-weight: 600;
        }

        .sidebar-close {
            background: none;
            border: none;
            font-size: 28px;
            color: var(--color-secondary-hover);
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            transition: var(--transition-medium);
        }

        .sidebar-close:hover {
            background: var(--color-border);
            color: var(--color-primary);
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }

        .sidebar-section {
            margin-bottom: 10px;
        }

        .sidebar-section-title {
            padding: 12px 20px 8px;
            margin: 0;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-secondary-hover);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sidebar-item {
            padding: 0;
        }

        .sidebar-item a,
        .sidebar-import-label {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            color: var(--color-primary);
            text-decoration: none;
            transition: var(--transition-medium);
            cursor: pointer;
            font-size: 14px;
        }

        .sidebar-item a:hover,
        .sidebar-import-label:hover {
            background: var(--color-hover-bg);
        }

        .sidebar-checkbox-label {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            cursor: pointer;
            transition: var(--transition-medium);
            font-size: 14px;
        }

        .sidebar-checkbox-label:hover {
            background: var(--color-hover-bg);
        }

        .sidebar-checkbox-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            margin: 0;
        }

        .sidebar-checkbox-label span {
            color: var(--color-primary);
            flex: 1;
        }

        /* Adjust body when sidebar is open to prevent scroll issues */
        body.sidebar-open {
            overflow: hidden;
        }
    </style>
</head>
<body>
    <!-- Skip to main content for keyboard/screen reader users -->
    <a href="#mainContent" class="skip-link">Skip to main content</a>

    <!-- Screen reader announcements for dynamic content updates -->
    <div id="srAnnounce" class="sr-announce" aria-live="polite" aria-atomic="true"></div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay" role="dialog" aria-labelledby="loadingText" aria-modal="true">
        <div class="loading-content">
            <div class="loading-spinner" aria-hidden="true"></div>
            <div class="loading-text" id="loadingText">Loading...</div>
        </div>
    </div>

    <div class="container" role="main">
        <header role="banner">
            <h1 id="headerTitle">PE Fund Manager</h1>
            <p id="headerSubtitle">Private Equity Fund Analytics & Management Tool</p>
        </header>

        <div class="controls-bar" role="search" aria-label="Filter and search controls">
            <div class="control-group">
                <label for="groupFilter">Filter by Group</label>
                <select id="groupFilter">
                    <option value="">All Groups</option>
                </select>
            </div>
            <div class="control-group">
                <label for="fundFilter">Filter by Fund</label>
                <select id="fundFilter">
                    <option value="">All Funds</option>
                </select>
            </div>
            <div class="control-group">
                <label for="accountFilter">Filter by Account</label>
                <select id="accountFilter">
                    <option value="">All Accounts</option>
                </select>
            </div>
            <div class="control-group">
                <label for="vintageFilter">Filter by Vintage</label>
                <select id="vintageFilter">
                    <option value="">All Vintages</option>
                </select>
            </div>
            <div class="control-group">
                <label for="searchInput">Search</label>
                <input type="text" id="searchInput" placeholder="Search funds..." title="Search by fund name or account number" aria-label="Search funds by name or account number">
            </div>
            <div class="control-group">
                <label for="cutoffDate" title="Calculate all metrics (IRR, MOIC, NAV, etc.) as of this date">Cutoff Date</label>
                <input type="date" id="cutoffDate" title="Calculate all metrics (IRR, MOIC, NAV, etc.) as of this date" aria-label="Cutoff date for calculating metrics">
            </div>
            <span id="activeFiltersIndicator" class="filter-badge" style="display: none;" aria-live="polite"></span>
            <!-- Filter loading indicator -->
            <div id="filterLoading" class="filter-loading" aria-live="polite">
                <div class="filter-loading-spinner" aria-hidden="true"></div>
                <span>Filtering...</span>
            </div>
            <div style="margin-left: auto;">
                <button class="btn-icon" id="toggleSidebarBtn" title="Settings and Actions" aria-label="Open settings sidebar" style="font-size: 20px;">☰</button>
            </div>
        </div>

        <div class="content" id="mainContent">
            <!-- Portfolio Summary Stats -->
            <div id="portfolioSummary" class="portfolio-summary">
                <div class="summary-stat">
                    <span class="summary-label">Funds</span>
                    <span class="summary-value" id="summaryFundCount">0</span>
                </div>
                <div class="summary-stat">
                    <span class="summary-label">Total Commitment</span>
                    <span class="summary-value" id="summaryCommitment">$0</span>
                </div>
                <div class="summary-stat">
                    <span class="summary-label">Total NAV</span>
                    <span class="summary-value" id="summaryNav">$0</span>
                </div>
                <div class="summary-stat">
                    <div class="summary-label-container">
                        <span class="summary-label">Avg IRR</span>
                        <span class="info-icon" aria-label="IRR explanation">?<span class="tooltip">Internal Rate of Return: The annualized return rate that makes the net present value of all cash flows equal to zero. Higher is better.</span></span>
                    </div>
                    <span class="summary-value" id="summaryIRR">N/A</span>
                </div>
                <div class="summary-stat">
                    <div class="summary-label-container">
                        <span class="summary-label">Avg MOIC</span>
                        <span class="info-icon" aria-label="MOIC explanation">?<span class="tooltip">Multiple on Invested Capital: Total value (distributions + NAV) divided by total contributions. A MOIC of 2.0x means you doubled your money.</span></span>
                    </div>
                    <span class="summary-value" id="summaryMOIC">N/A</span>
                </div>
                <div class="summary-stat">
                    <div class="summary-label-container">
                        <span class="summary-label">DPI</span>
                        <span class="info-icon" aria-label="DPI explanation">?<span class="tooltip">Distributions to Paid-In: Total distributions divided by total contributions. Measures actual cash returned to investors. DPI of 1.0x means all invested capital has been returned.</span></span>
                    </div>
                    <span class="summary-value" id="summaryDPI">N/A</span>
                </div>
                <div class="summary-stat">
                    <div class="summary-label-container">
                        <span class="summary-label">RVPI</span>
                        <span class="info-icon" aria-label="RVPI explanation">?<span class="tooltip">Residual Value to Paid-In: Current NAV divided by total contributions. Represents unrealized value still held in the fund.</span></span>
                    </div>
                    <span class="summary-value" id="summaryRVPI">N/A</span>
                </div>
                <div class="summary-stat">
                    <div class="summary-label-container">
                        <span class="summary-label">TVPI</span>
                        <span class="info-icon" aria-label="TVPI explanation">?<span class="tooltip">Total Value to Paid-In: DPI + RVPI. Total value (distributions + NAV) divided by contributions. The most comprehensive measure of fund performance.</span></span>
                    </div>
                    <span class="summary-value" id="summaryTVPI">N/A</span>
                </div>
            </div>

            <!-- Cash Flow Timeline Panel -->
            <div id="timelinePanel" class="timeline-panel">
                <div class="timeline-header" id="timelineHeader">
                    <h3>
                        <span>Cash Flow Timeline</span>
                        <span style="font-weight: normal; font-size: 12px; color: var(--color-text-light);">(Historical + Projected)</span>
                    </h3>
                    <span class="timeline-toggle">▼</span>
                </div>
                <div class="timeline-content">
                    <div id="timelineTableContainer">
                        <p class="timeline-no-data">No investments to display. <a href="#" onclick="showAddFundModal(); return false;" style="color: var(--color-action);">Add your first investment</a> with cash flows to see the timeline.</p>
                    </div>
                </div>
            </div>

            <div class="table-container">
                <table id="fundsTable">
                    <thead>
                        <tr>
                            <th data-sort="fundName">Fund Name</th>
                            <th data-sort="accountNumber" class="center">Investor</th>
                            <th data-sort="vintage" class="center">Vintage</th>
                            <th data-sort="commitment" class="center number">Commitment</th>
                            <th data-sort="totalContributions" class="center number">Contributions</th>
                            <th data-sort="totalDistributions" class="center number">Distributions</th>
                            <th data-sort="nav" class="center number">Value (NAV)</th>
                            <th data-sort="investmentReturn" class="center number wrap-header">Investment<br>Return</th>
                            <th data-sort="moic" class="center number">MOIC</th>
                            <th data-sort="irr" class="center number">IRR</th>
                            <th data-sort="outstandingCommitment" class="center number wrap-header">Outstanding<br>Commitment</th>
                            <th class="center"></th>
                        </tr>
                    </thead>
                    <tbody id="fundsTableBody">
                        <!-- Data will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Fund Add/Edit Modal -->
    <div id="fundModal" class="modal">
        <div class="modal-content">
            <span class="close" id="closeFundModalBtn">&times;</span>
            <h2 id="fundModalTitle">Add New Investment</h2>
            <form id="fundForm">
                <input type="hidden" id="fundId">
                <input type="hidden" id="isDuplicate">

                <div class="form-group">
                    <label for="fundName">Fund Name *</label>
                    <select id="fundName" required></select>
                    <div id="newFundNameContainer" style="display: none; margin-top: 8px;">
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="newFundNameInline" placeholder="Enter new fund name" style="flex: 1;">
                            <button type="button" class="btn-primary" id="addNewFundNameBtn" style="padding: 8px 12px; white-space: nowrap;">Add</button>
                            <button type="button" class="btn-secondary" id="cancelNewFundNameBtn" style="padding: 8px 12px;">Cancel</button>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="accountNumber">Account Number *</label>
                    <input type="text" id="accountNumber" required>
                </div>

                <div class="form-group">
                    <label for="fundGroup">Group (optional)</label>
                    <select id="fundGroup">
                        <option value="">No Group</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="commitment">Commitment (USD) *</label>
                    <input type="text" id="commitment" required placeholder="e.g., 1,000,000">
                </div>

                <div id="duplicateMultiplierContainer" class="form-group" style="display: none;">
                    <label for="duplicateMultiplier">Duplicate Multiplier</label>
                    <input type="number" id="duplicateMultiplier" step="any" value="1">
                </div>

                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <label for="cashFlows">Cash Flows (JSON)</label>
                        <button type="button" class="btn-link" onclick="fillCashFlowsExample()" style="font-size: 12px;">View Example</button>
                    </div>
                    <textarea id="cashFlows" placeholder='[{"date":"2024-01-15","amount":-1000000,"type":"Contribution","affectsCommitment":true}]'></textarea>
                    <div class="hint">Format: [{"date":"YYYY-MM-DD","amount":number,"type":"Contribution|Distribution","affectsCommitment":true}]</div>
                </div>

                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <label for="monthlyNav">Monthly NAV (JSON)</label>
                        <button type="button" class="btn-link" onclick="fillNavExample()" style="font-size: 12px;">View Example</button>
                    </div>
                    <textarea id="monthlyNav" placeholder='[{"date":"2024-01-31","amount":950000}]'></textarea>
                    <div class="hint">Format: [{"date":"YYYY-MM-DD","amount":number}]</div>
                </div>

                <div class="form-actions">
                    <button type="submit" class="btn-primary" id="saveFundBtn">Save</button>
                    <button type="button" class="btn-secondary" id="cancelFundModalBtn">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Action Dropdown -->
    <div id="actionDropdown" class="action-dropdown">
        <a href="#" id="actionEdit">Edit</a>
        <a href="#" id="actionDuplicate">Duplicate</a>
        <a href="#" id="actionViewDetails">View Details</a>
        <a href="#" id="actionDelete" class="danger-action">Delete</a>
    </div>

    <!-- Manage Fund Names Modal -->
    <div id="manageFundNamesModal" class="modal">
        <div class="modal-content">
            <span class="close" id="closeManageFundsModalBtn">&times;</span>
            <h2>Manage Fund Names</h2>

            <div class="form-group">
                <label for="newFundNameInput">Add New Fund Name</label>
                <input type="text" id="newFundNameInput" placeholder="Enter fund name">
            </div>

            <details id="newFundTermsDetails" style="margin-bottom: 15px;">
                <summary style="cursor: pointer; color: var(--color-action); font-size: 13px; margin-bottom: 10px;">+ Add Fund Terms (optional)</summary>
                <div style="padding: 10px; background: var(--color-alt-bg); border-radius: var(--radius-sm); margin-top: 10px;">
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label for="newFundFirstClose" style="font-size: 12px;">First Close Date</label>
                            <input type="date" id="newFundFirstClose">
                        </div>
                        <div class="form-group" style="flex: 1; margin-bottom: 0;">
                            <label for="newFundFinalClose" style="font-size: 12px;">Final Close Date</label>
                            <input type="date" id="newFundFinalClose">
                        </div>
                    </div>
                    <div class="form-group" style="margin-bottom: 0;">
                        <label for="newFundInvestmentTerm" style="font-size: 12px;">Investment Term (years)</label>
                        <input type="number" id="newFundInvestmentTerm" min="1" max="15" step="1" placeholder="e.g., 5">
                    </div>
                </div>
            </details>

            <button class="btn-primary" id="addNewFundNameBtn" style="width: 100%;">Add Fund Name</button>

            <hr style="margin: 20px 0; border: none; border-top: 1px solid var(--color-border);">

            <h3 style="margin-bottom: 15px; color: #2C3E50; font-weight: 600; font-size: 1.1em;">Existing Fund Names</h3>
            <div id="fundNamesList"></div>

            <div class="form-actions">
                <button class="btn-secondary" id="closeManageFundsModal2Btn">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Fund Name Modal -->
    <div id="editFundNameModal" class="modal">
        <div class="modal-content">
            <span class="close" id="closeEditFundNameModalBtn">&times;</span>
            <h2>Edit Fund</h2>

            <input type="hidden" id="editFundNameOriginal" value="">

            <div class="form-group">
                <label for="editFundNameInput">Fund Name</label>
                <input type="text" id="editFundNameInput" placeholder="Enter fund name">
            </div>

            <div class="form-group">
                <label for="editFundTags">Tags (optional)</label>
                <div id="editFundTagsContainer" class="tags-container"></div>
                <input type="text" id="editFundTagsInput" placeholder="Add tag (e.g., Venture Capital, Growth Equity)" list="editFundTagsDatalist">
                <datalist id="editFundTagsDatalist"></datalist>
                <div class="hint">Press Enter to add tags. Click × on a tag to remove it.</div>
            </div>

            <h3 style="margin: 20px 0 15px 0; color: var(--color-text); font-weight: 600; font-size: 1em; border-top: 1px solid var(--color-border); padding-top: 20px;">Fund Terms (for capital call projections)</h3>

            <div class="form-row" style="display: flex; gap: 15px;">
                <div class="form-group" style="flex: 1;">
                    <label for="editFundFirstClose">First Close Date</label>
                    <input type="date" id="editFundFirstClose">
                </div>
                <div class="form-group" style="flex: 1;">
                    <label for="editFundFinalClose">Final Close Date</label>
                    <input type="date" id="editFundFinalClose">
                </div>
            </div>

            <div class="form-group">
                <label for="editFundInvestmentTerm">Investment Term (years)</label>
                <input type="number" id="editFundInvestmentTerm" min="1" max="15" step="1" placeholder="e.g., 5">
                <div class="hint">Number of years from final close during which capital can be called (typically 3-5 years)</div>
            </div>

            <div class="form-actions">
                <button class="btn-primary" id="saveEditedFundNameBtn">Save Changes</button>
                <button class="btn-secondary" id="cancelEditFundNameBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Manage Groups Modal -->
    <div id="manageGroupsModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <span class="close" id="closeManageGroupsModal2Btn">&times;</span>
            <h2>Manage Account Groups</h2>

            <input type="hidden" id="editGroupId" value="">
            <h3 id="groupFormTitle" style="margin-bottom: 15px; color: #2C3E50; font-weight: 600; font-size: 1.1em;">Add New Group</h3>

            <div class="form-group">
                <label for="newGroupName">Group Name</label>
                <input type="text" id="newGroupName" placeholder="e.g., John Smith, Smith Family Trust">
                <small style="color: #7f8c8d; font-size: 0.85em; margin-top: 4px; display: block;">Use groups to organize by account holder or entity (e.g., individuals, trusts, IRAs)</small>
            </div>

            <div class="form-group">
                <label for="newGroupParent">Parent Group (optional)</label>
                <select id="newGroupParent">
                    <option value="">None (Top Level)</option>
                </select>
            </div>

            <div class="form-group">
                <label for="newGroupType">Type (optional)</label>
                <input type="text" id="newGroupType" placeholder="e.g., Client, Trust, Account">
            </div>

            <div style="display: flex; gap: 10px;">
                <button id="saveGroupBtn" class="btn-primary">Add Group</button>
                <button id="cancelEditBtn" class="btn-secondary" style="display: none;">Cancel</button>
            </div>

            <hr style="margin: 20px 0; border: none; border-top: 1px solid #E0E0E0;">

            <h3 style="margin-bottom: 15px; color: #2C3E50; font-weight: 600; font-size: 1.1em;">Existing Groups</h3>
            <div id="groupsList" style="max-height: 400px; overflow-y: auto;"></div>

            <div class="form-actions">
                <button class="btn-secondary" id="closeManageGroupsModalBtn">Close</button>
            </div>
        </div>
    </div>

    <!-- Details Modal -->
    <div id="detailsModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <span class="close" id="closeDetailsModalBtn">&times;</span>
            <h2 id="detailsModalTitle">Fund Details</h2>
            <p id="detailsModalSubtitle" style="margin: 5px 0 0 0; color: #95A5A6; font-size: 0.9em;"></p>

            <h3 style="margin-top: 20px; color: #2C3E50; font-weight: 600; font-size: 1.1em;">Cash Flows</h3>
            <div class="details-table-wrapper">
                <table class="details-table" id="cashFlowsTable">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th class="number">Amount (USD)</th>
                            <th class="center">Type</th>
                            <th class="center">Affects Commitment?</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <button type="button" class="btn-primary btn-sm" style="margin-top: 10px;" id="addCashFlowRowBtn">Add Cash Flow</button>

            <h3 style="margin-top: 30px; color: #2C3E50; font-weight: 600; font-size: 1.1em;">Monthly NAV</h3>
            <div class="details-table-wrapper">
                <table class="details-table" id="navTable">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Amount (USD)</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <button type="button" class="btn-primary btn-sm" style="margin-top: 10px;" id="addNavRowBtn">Add NAV</button>

            <div class="form-actions">
                <button class="btn-primary" id="saveDetailsChangesBtn">Save Changes</button>
                <button class="btn-secondary" id="cancelDetailsModalBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Backup Warning Modal -->
    <div id="backupWarningModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <span class="close" id="closeBackupWarningBtn">&times;</span>
            <h2 style="color: #E67E22; margin-bottom: 15px;">⚠️ Important: Backup Your Data</h2>
            <p style="line-height: 1.6; margin-bottom: 15px;">
                Your PE Fund Manager data is stored <strong>locally in your browser</strong>.
                This means your data could be lost if:
            </p>
            <ul style="margin: 15px 0 15px 25px; line-height: 1.8;">
                <li>You clear your browser cache or cookies</li>
                <li>You uninstall your browser</li>
                <li>Your computer crashes or is reset</li>
                <li>You switch to a different device</li>
            </ul>
            <p style="line-height: 1.6; margin-bottom: 20px; font-weight: 600; color: #E74C3C;">
                Please export your data regularly to avoid data loss!
            </p>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="dontShowBackupWarning" style="margin-right: 8px;">
                    Don't show this warning again (you'll see a reminder every 30 days)
                </label>
            </div>
            <div class="form-actions">
                <button class="btn-success" id="exportNowBtn">Export Now</button>
                <button class="btn-secondary" id="remindLaterBtn">Remind Me Later</button>
            </div>
        </div>
    </div>

    <!-- Keyboard Shortcuts Help Modal -->
    <div id="shortcutsModal" class="modal shortcuts-modal">
        <div class="modal-content">
            <span class="close" id="closeShortcutsModalBtn">&times;</span>
            <h2>Keyboard Shortcuts</h2>
            <div class="shortcuts-list">
                <div class="shortcut-key"><kbd>?</kbd></div>
                <div class="shortcut-desc">Show this help</div>

                <div class="shortcut-key"><kbd>Ctrl</kbd> + <kbd>F</kbd></div>
                <div class="shortcut-desc">Focus search input</div>

                <div class="shortcut-key"><kbd>Ctrl</kbd> + <kbd>N</kbd></div>
                <div class="shortcut-desc">Add new investment</div>

                <div class="shortcut-key"><kbd>Ctrl</kbd> + <kbd>E</kbd></div>
                <div class="shortcut-desc">Export to JSON</div>

                <div class="shortcut-key"><kbd>Ctrl</kbd> + <kbd>S</kbd></div>
                <div class="shortcut-desc">Save (in details modal)</div>

                <div class="shortcut-key"><kbd>Esc</kbd></div>
                <div class="shortcut-desc">Close modal/sidebar</div>

                <div class="shortcut-key"><kbd>↑</kbd> / <kbd>↓</kbd></div>
                <div class="shortcut-desc">Navigate table rows (when focused)</div>

                <div class="shortcut-key"><kbd>Enter</kbd></div>
                <div class="shortcut-desc">Open fund details (when row focused)</div>

                <div class="shortcut-key"><kbd>Space</kbd></div>
                <div class="shortcut-desc">Open action menu (when row focused)</div>
            </div>
            <p style="margin-top: 20px; font-size: 12px; color: var(--color-text-light);">
                On Mac, use <kbd style="display: inline-block; padding: 2px 6px; font-family: monospace; font-size: 11px; background: var(--color-alt-bg); border: 1px solid var(--color-border); border-radius: 3px;">⌘</kbd> instead of <kbd style="display: inline-block; padding: 2px 6px; font-family: monospace; font-size: 11px; background: var(--color-alt-bg); border: 1px solid var(--color-border); border-radius: 3px;">Ctrl</kbd>
            </p>
            <div class="form-actions">
                <button class="btn-secondary" id="closeShortcutsModal2Btn">Close</button>
            </div>
        </div>
    </div>

    <!-- Sidebar Panel -->
    <div id="sidebarOverlay" class="sidebar-overlay"></div>
    <div id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <h3>Settings & Actions</h3>
            <button class="sidebar-close" id="closeSidebarBtn" title="Close">&times;</button>
        </div>
        <div class="sidebar-content">
            <!-- View Options Section -->
            <div class="sidebar-section">
                <h4 class="sidebar-section-title">View Options</h4>
                <div class="sidebar-item">
                    <label class="sidebar-checkbox-label">
                        <input type="checkbox" id="sidebarShowTagsCheckbox" checked>
                        <span>Show Tags</span>
                    </label>
                </div>
                <div class="sidebar-item">
                    <label class="sidebar-checkbox-label">
                        <input type="checkbox" id="sidebarDarkModeCheckbox">
                        <span>Dark Mode</span>
                    </label>
                </div>
            </div>

            <!-- Manage Section -->
            <div class="sidebar-section">
                <h4 class="sidebar-section-title">Manage</h4>
                <div class="sidebar-item">
                    <a href="#" id="sidebarNewInvestment">
                        New Investment
                    </a>
                </div>
                <div class="sidebar-item">
                    <a href="#" id="sidebarManageFunds">
                        Manage Funds
                    </a>
                </div>
                <div class="sidebar-item">
                    <a href="#" id="sidebarManageGroups">
                        Manage Groups
                    </a>
                </div>
            </div>

            <!-- Data Section -->
            <div class="sidebar-section">
                <h4 class="sidebar-section-title">Data</h4>
                <div class="sidebar-item">
                    <a href="#" id="sidebarExportCSV">
                        Export to CSV
                    </a>
                </div>
                <div class="sidebar-item">
                    <a href="#" id="sidebarExportJSON">
                        Export to JSON
                    </a>
                </div>
                <div class="sidebar-item">
                    <a href="#" id="sidebarExportPDF">
                        Export to PDF
                    </a>
                </div>
                <div class="sidebar-item">
                    <label for="sidebarImportFile" class="sidebar-import-label">
                        Import JSON
                    </label>
                    <input type="file" id="sidebarImportFile" accept=".json" style="display: none;">
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * PE Fund Manager - Private Equity Fund Analytics & Management Tool
         *
         * A comprehensive single-file application for managing private equity fund investments.
         * All data is stored locally in IndexedDB with no external dependencies.
         *
         * Key Features:
         * - Fund portfolio management with cash flows and NAV tracking
         * - IRR and MOIC calculations using Newton-Raphson method
         * - Hierarchical account grouping with cycle detection
         * - CSV/JSON import/export with formula injection protection
         * - Mobile-responsive design with accessibility features
         * - Performance optimizations: metrics caching, debouncing, race condition handling
         * - Input validation and sanitization for security
         * - Automatic backup reminders with local storage tracking
         *
         * Architecture:
         * - State Management: Centralized AppState object with caching
         * - Database: IndexedDB with 3 stores (funds, fundNames, groups)
         * - UI: Event-driven with delegation patterns and keyboard shortcuts
         * - Performance: Debounced filters, cached metrics, abort controllers for cancellation
         *
         * @version 2.0.0
         * @author PE Fund Manager Team
         * @license MIT
         */
        (function() {
            'use strict';

            // ===========================
            // Configuration & Constants
            // ===========================

        /**
         * Application configuration constants
         * @const {Object}
         */
        const CONFIG = {
            // Database
            DB_NAME: 'FundsDB',
            FUNDS_STORE: 'funds',
            FUNDNAMES_STORE: 'fundNames',
            GROUPS_STORE: 'groups',
            DB_VERSION: 8,

            // Currency formatting
            CURRENCY_FORMAT: 'en-US',
            CURRENCY_CODE: 'USD',
            CURRENCY_MIN: -1e12,
            CURRENCY_MAX: 1e12,

            // IRR calculation
            IRR_MAX_ITERATIONS: 1000,
            IRR_PRECISION: 1e-6,
            IRR_GUESS: 0.1,
            IRR_MIN_RATE: -0.99,
            IRR_MAX_RATE: 10.0,

            // Date format validation
            DATE_FORMAT: /^\d{4}-\d{2}-\d{2}$/,

            // Debounce delays (ms)
            DEBOUNCE_FILTER: 300,
            DEBOUNCE_SEARCH: 300,
            DEBOUNCE_INPUT: 300,

            // UI constraints
            MIN_COLUMN_WIDTH: 50,
            MAX_FILE_SIZE: 50 * 1024 * 1024, // 50MB
            FUND_NAME_MIN_LENGTH: 2,
            FUND_NAME_MAX_LENGTH: 100,

            // Performance
            METRICS_CACHE_TTL: 5000, // 5 seconds
            LAZY_RENDER_TIMELINE: true, // Only render timeline when expanded

            // Validation & Security
            ALLOWED_FUND_NAME_PATTERN: /^[a-zA-Z0-9\s\-_.,&']+$/, // Removed parentheses for security
            MAX_IMPORT_FUNDS: 10000,
            MAX_IMPORT_GROUPS: 1000,
            MAX_IMPORT_FUNDNAMES: 5000,
            MAX_JSON_DEPTH: 10,
            DANGEROUS_KEYS: ['__proto__', 'constructor', 'prototype'], // Prototype pollution prevention

            // LocalStorage keys
            STORAGE_COLUMN_WIDTHS: 'columnWidths',
            STORAGE_SHOW_TAGS: 'showTags',
            STORAGE_BACKUP_WARNING: 'backupWarningShown',
            STORAGE_LAST_BACKUP: 'lastBackupDate',

            // Backup reminder
            BACKUP_REMINDER_DAYS: 30
        };

        // ===========================
        // Debug Logger
        // ===========================

        /**
         * Debug logger that can be toggled on/off
         * @namespace Debug
         */
        const Debug = {
            enabled: false, // Set to true to enable debug logging
            log(...args) {
                if (this.enabled) console.log('[DEBUG]', ...args);
            },
            warn(...args) {
                if (this.enabled) console.warn('[DEBUG]', ...args);
            },
            error(...args) {
                // Errors always log
                console.error('[ERROR]', ...args);
            }
        };

        // ===========================
        // Utility Functions
        // ===========================

        /**
         * Debounce function to limit rate of function calls
         * @param {Function} func - Function to debounce
         * @param {number} wait - Wait time in milliseconds
         * @returns {Function} Debounced function
         */
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        /**
         * Sanitize object to prevent prototype pollution attacks
         * @param {Object} obj - Object to sanitize
         * @param {number} depth - Current recursion depth
         * @returns {Object} Sanitized object
         */
        function sanitizeObject(obj, depth = 0) {
            if (depth > CONFIG.MAX_JSON_DEPTH) {
                throw new Error('Object too deeply nested');
            }

            if (obj === null || typeof obj !== 'object') {
                return obj;
            }

            if (Array.isArray(obj)) {
                return obj.map(item => sanitizeObject(item, depth + 1));
            }

            const sanitized = Object.create(null);
            for (const key of Object.keys(obj)) {
                // Skip dangerous keys that could cause prototype pollution
                if (CONFIG.DANGEROUS_KEYS.includes(key)) {
                    console.warn(`Blocked potentially dangerous key: ${key}`);
                    continue;
                }
                sanitized[key] = sanitizeObject(obj[key], depth + 1);
            }
            return sanitized;
        }

        /**
         * Safe JSON parse with prototype pollution protection
         * @param {string} jsonString - JSON string to parse
         * @returns {Object} Parsed and sanitized object
         */
        function safeJSONParse(jsonString) {
            const parsed = JSON.parse(jsonString);
            return sanitizeObject(parsed);
        }

        /**
         * Deep clone an object safely
         * @param {Object} obj - Object to clone
         * @returns {Object} Cloned object
         */
        function deepClone(obj) {
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }
            if (obj instanceof Date) {
                return new Date(obj.getTime());
            }
            if (Array.isArray(obj)) {
                return obj.map(item => deepClone(item));
            }
            const cloned = {};
            for (const key of Object.keys(obj)) {
                cloned[key] = deepClone(obj[key]);
            }
            return cloned;
        }

        /**
         * Announce message to screen readers
         * @param {string} message - Message to announce
         */
        function announceToScreenReader(message) {
            const announcer = document.getElementById('srAnnounce');
            if (announcer) {
                announcer.textContent = message;
                // Clear after announcement to allow repeat announcements
                setTimeout(() => {
                    announcer.textContent = '';
                }, 1000);
            }
        }

        /**
         * Show/hide filter loading indicator
         * @param {boolean} show - Whether to show or hide
         */
        function setFilterLoading(show) {
            const indicator = document.getElementById('filterLoading');
            if (indicator) {
                indicator.classList.toggle('show', show);
            }
        }

        /**
         * Normalize date to avoid timezone issues
         * Creates a date at noon local time to avoid day-boundary problems
         * @param {string} dateStr - Date string in YYYY-MM-DD format
         * @returns {Date} Normalized date object
         */
        function normalizeDate(dateStr) {
            if (!dateStr || typeof dateStr !== 'string') return null;
            const [year, month, day] = dateStr.split('-').map(Number);
            if (!year || !month || !day) return null;
            // Create date at noon to avoid timezone issues
            return new Date(year, month - 1, day, 12, 0, 0, 0);
        }

        /**
         * Consistent error handler for async operations
         * @param {Error} error - The error object
         * @param {string} operation - Description of the operation that failed
         * @param {boolean} showToUser - Whether to show error message to user
         */
        function handleError(error, operation, showToUser = true) {
            const message = `Error in ${operation}: ${error.message}`;
            console.error(message, error);
            if (showToUser) {
                showStatus(message, 'error');
            }
        }

        /**
         * Safe localStorage operations with error handling
         * @namespace Storage
         */
        const Storage = {
            /**
             * Get item from localStorage with error handling
             * @param {string} key - Storage key
             * @param {*} defaultValue - Default value if not found
             * @returns {*} Parsed value or default
             */
            get(key, defaultValue = null) {
                try {
                    const item = localStorage.getItem(key);
                    return item ? JSON.parse(item) : defaultValue;
                } catch (error) {
                    console.error(`Error reading from localStorage: ${key}`, error);
                    return defaultValue;
                }
            },

            /**
             * Set item in localStorage with error handling
             * @param {string} key - Storage key
             * @param {*} value - Value to store
             * @returns {boolean} Success status
             */
            set(key, value) {
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                    return true;
                } catch (error) {
                    console.error(`Error writing to localStorage: ${key}`, error);
                    if (error.name === 'QuotaExceededError') {
                        console.warn('localStorage quota exceeded');
                    }
                    return false;
                }
            },

            /**
             * Remove item from localStorage with error handling
             * @param {string} key - Storage key
             * @returns {boolean} Success status
             */
            remove(key) {
                try {
                    localStorage.removeItem(key);
                    return true;
                } catch (error) {
                    console.error(`Error removing from localStorage: ${key}`, error);
                    return false;
                }
            }
        };

        // ===========================
        // Modal Manager
        // ===========================

        /**
         * Centralized modal management
         * @namespace Modal
         */
        const Modal = {
            /**
             * Show a modal by ID
             * @param {string} modalId - The modal element ID
             * @param {Object} options - Optional callbacks
             */
            show(modalId, options = {}) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.add('show');
                    if (options.onShow) options.onShow(modal);
                }
            },

            /**
             * Close a modal by ID
             * @param {string} modalId - The modal element ID
             * @param {Object} options - Optional callbacks and settings
             * @returns {boolean} Whether the modal was closed
             */
            close(modalId, options = {}) {
                const modal = document.getElementById(modalId);
                if (!modal) return false;

                // Check for unsaved changes if specified
                if (options.checkUnsaved && AppState.hasUnsavedChanges) {
                    if (!confirm('You have unsaved changes. Are you sure you want to close without saving?')) {
                        return false;
                    }
                }

                modal.classList.remove('show');
                if (options.onClose) options.onClose(modal);
                return true;
            },

            /**
             * Check if a modal is open
             * @param {string} modalId - The modal element ID
             * @returns {boolean}
             */
            isOpen(modalId) {
                const modal = document.getElementById(modalId);
                return modal ? modal.classList.contains('show') : false;
            }
        };

        // ===========================
        // Number Formatter
        // ===========================

        /**
         * Centralized number formatting utilities
         * @namespace Formatter
         */
        const Formatter = {
            /**
             * Format a number with options
             * @param {number} value - Value to format
             * @param {Object} options - Formatting options
             * @returns {string} Formatted string
             */
            number(value, options = {}) {
                const {
                    prefix = '',
                    suffix = '',
                    decimals = 0,
                    fallback = 'N/A',
                    showSign = false,
                    useCommas = true
                } = options;

                if (value === null || value === undefined || isNaN(value)) {
                    return fallback;
                }

                let formatted = useCommas
                    ? value.toLocaleString(CONFIG.CURRENCY_FORMAT, {
                        minimumFractionDigits: decimals,
                        maximumFractionDigits: decimals
                    })
                    : value.toFixed(decimals);

                if (showSign && value > 0) {
                    formatted = '+' + formatted;
                }

                return prefix + formatted + suffix;
            },

            /**
             * Format as currency
             * @param {number} value - Value to format
             * @returns {string}
             */
            currency(value) {
                return this.number(value, { prefix: '$', decimals: 0, fallback: '$0' });
            },

            /**
             * Format as percentage (for IRR)
             * @param {number} value - Decimal value (0.15 = 15%)
             * @returns {string}
             */
            percent(value) {
                if (value === null || value === undefined) return 'N/A';
                return this.number(value * 100, { suffix: '%', decimals: 1, fallback: 'N/A' });
            },

            /**
             * Format as multiple (for MOIC)
             * @param {number} value - Multiple value
             * @returns {string}
             */
            multiple(value) {
                return this.number(value, { suffix: 'x', decimals: 2, fallback: 'N/A' });
            }
        };

        // ===========================
        // HTML Template Builders
        // ===========================

        /**
         * HTML template builders for reusable components
         * @namespace Templates
         */
        const Templates = {
            /**
             * Create a cash flow table row
             * @param {Object} cf - Cash flow data (or empty for new row)
             * @param {number} index - Row index
             * @returns {string} HTML string
             */
            cashFlowRow(cf = {}, index) {
                const dateValue = cf.date ? escapeHtml(cf.date) : '';
                const amountValue = cf.amount !== undefined ? formatNumberWithCommas(parseCurrency(cf.amount)) : '';
                const typeValue = cf.type || 'Contribution';
                const affectsCommitment = cf.affectsCommitment !== false;

                return `
                    <tr>
                        <td><input type="date" value="${dateValue}" data-field="date" data-index="${index}"></td>
                        <td class="number"><input type="text" value="${amountValue}" placeholder="0" data-field="amount" data-index="${index}"></td>
                        <td class="center">
                            <select data-field="type" data-index="${index}">
                                <option value="Contribution" ${typeValue === 'Contribution' ? 'selected' : ''}>Contribution</option>
                                <option value="Distribution" ${typeValue === 'Distribution' ? 'selected' : ''}>Distribution</option>
                            </select>
                        </td>
                        <td class="center">
                            <input type="checkbox" ${affectsCommitment ? 'checked' : ''} data-field="affectsCommitment" data-index="${index}">
                        </td>
                        <td>
                            <button class="delete-row-btn" data-action="deleteCashFlow" title="Delete">×</button>
                        </td>
                    </tr>
                `;
            },

            /**
             * Create a NAV table row
             * @param {Object} nav - NAV data (or empty for new row)
             * @param {number} index - Row index
             * @returns {string} HTML string
             */
            navRow(nav = {}, index) {
                const dateValue = nav.date ? escapeHtml(nav.date) : '';
                const amountValue = nav.amount !== undefined ? formatNumberWithCommas(parseCurrency(nav.amount)) : '';

                return `
                    <tr>
                        <td><input type="date" value="${dateValue}" data-field="date" data-index="${index}"></td>
                        <td><input type="text" value="${amountValue}" placeholder="0" data-field="amount" data-index="${index}"></td>
                        <td>
                            <button class="delete-row-btn" data-action="deleteNav" title="Delete">×</button>
                        </td>
                    </tr>
                `;
            },

            /**
             * Create a fund table row
             * @param {Object} fund - Fund with metrics
             * @param {number} index - Row index
             * @param {boolean} showTags - Whether to show tags
             * @returns {string} HTML string
             */
            fundRow(fund, index, showTags = false) {
                const m = fund.metrics;
                const fundNameObj = AppState.fundNameData.get(fund.fundName);
                const tags = fundNameObj && fundNameObj.tags ? fundNameObj.tags : [];
                const tagsHtml = (showTags && tags.length > 0)
                    ? `<div class="table-tags">${tags.map(tag => `<span class="table-tag">${escapeHtml(tag)}</span>`).join('')}</div>`
                    : '';

                return `
                    <td>
                        <div>${escapeHtml(fund.fundName)}</div>
                        ${tagsHtml}
                    </td>
                    <td title="${escapeHtml(getParentAccountDisplay(fund))}">${getInvestorCellHtml(fund)}</td>
                    <td class="center">${m.vintage || 'N/A'}</td>
                    <td class="number">${formatCurrency(m.commitment)}</td>
                    <td class="number">${formatCurrency(m.totalContributions)}</td>
                    <td class="number">${formatCurrency(m.totalDistributions)}</td>
                    <td class="number">${formatCurrency(m.nav)}</td>
                    <td class="number ${m.investmentReturn >= 0 ? 'positive' : 'negative'}">${formatCurrency(m.investmentReturn)}</td>
                    <td class="number">${formatMOIC(m.moic)}</td>
                    <td class="number ${m.irr !== null && m.irr >= 0 ? 'positive' : 'negative'}">${formatIRR(m.irr)}</td>
                    <td class="number">${formatCurrency(m.outstandingCommitment)}</td>
                    <td class="center">
                        <button class="btn-icon fund-actions-btn" data-fund-id="${fund.id}" title="Actions" aria-label="Actions for ${escapeHtml(fund.fundName)}">⚙</button>
                    </td>
                `;
            }
        };

        // ===========================
        // Cash Flow Helpers
        // ===========================

        /**
         * Get filtered cash flows with common filtering logic
         * @param {Object} fund - Fund object
         * @param {Date|null} cutoffDate - Optional cutoff date
         * @param {string|null} typeFilter - Optional type filter ('Contribution' or 'Distribution')
         * @returns {Array} Filtered cash flows
         */
        function getFilteredCashFlows(fund, cutoffDate = null, typeFilter = null) {
            return (fund.cashFlows || []).filter(cf =>
                isValidDate(cf.date) &&
                (!cutoffDate || new Date(cf.date) <= cutoffDate) &&
                (!typeFilter || cf.type === typeFilter)
            );
        }

        /**
         * Get filtered NAV entries
         * @param {Object} fund - Fund object
         * @param {Date|null} cutoffDate - Optional cutoff date
         * @returns {Array} Filtered NAV entries sorted by date descending
         */
        function getFilteredNavs(fund, cutoffDate = null) {
            return (fund.monthlyNav || [])
                .filter(n => isValidDate(n.date) && (!cutoffDate || new Date(n.date) <= cutoffDate))
                .sort((a, b) => new Date(b.date) - new Date(a.date));
        }

        // ===========================
        // Filter Configuration
        // ===========================

        /**
         * Filter configurations for declarative filtering
         */
        const FilterConfigs = [
            {
                id: 'fundFilter',
                apply: (fund, value) => !value || fund.fundName === value
            },
            {
                id: 'accountFilter',
                apply: (fund, value) => !value || fund.accountNumber === value
            },
            {
                id: 'vintageFilter',
                apply: (fund, value) => {
                    if (!value) return true;
                    const vintage = getVintageYear(fund);
                    return vintage && vintage.toString() === value;
                }
            },
            {
                id: 'searchInput',
                apply: (fund, value) => {
                    if (!value) return true;
                    const searchLower = value.toLowerCase();
                    return (
                        fund.fundName.toLowerCase().includes(searchLower) ||
                        (fund.accountNumber && fund.accountNumber.toLowerCase().includes(searchLower))
                    );
                }
            }
        ];

        // ===========================
        // IndexedDB Operations
        // ===========================

        // Database state (maintained for backward compatibility)
        let db;
        let dbReady = false;
        const DB_NAME = CONFIG.DB_NAME;
        const FUNDS_STORE = CONFIG.FUNDS_STORE;
        const FUNDNAMES_STORE = CONFIG.FUNDNAMES_STORE;
        const GROUPS_STORE = CONFIG.GROUPS_STORE;
        const DB_VERSION = CONFIG.DB_VERSION;

        // Application state - centralized state management (single source of truth)
        const AppState = {
            // Data
            currentFunds: [],
            fundNames: new Set(),
            fundNameData: new Map(),
            groups: [],
            groupsMap: new Map(), // O(1) lookup map: groupId -> group
            groupDescendantsCache: new Map(), // groupId -> array of descendant IDs
            ancestorCache: new Map(), // groupId -> array of ancestor IDs (memoization)

            // UI state
            currentGroupDescendants: null,
            sortColumns: [], // Array of {column, direction} for multi-column sorting
            currentActionFundId: null,
            currentDetailsFundId: null,
            hasUnsavedChanges: false,
            isResizingColumn: false,
            lastMousedownOnResizer: false,

            // Cache
            metricsCache: new Map(), // fundId -> { metrics, timestamp }

            // Performance
            abortController: null, // For canceling in-flight requests

            // Getters
            getFunds() { return this.currentFunds; },
            getGroups() { return this.groups; },

            // Cache management
            clearMetricsCache() {
                this.metricsCache.clear();
            },

            getMetricsFromCache(fundId, cutoffDate) {
                const key = `${fundId}-${cutoffDate}`;
                const cached = this.metricsCache.get(key);
                if (cached && (Date.now() - cached.timestamp < CONFIG.METRICS_CACHE_TTL)) {
                    return cached.metrics;
                }
                return null;
            },

            setMetricsCache(fundId, cutoffDate, metrics) {
                const key = `${fundId}-${cutoffDate}`;
                this.metricsCache.set(key, { metrics, timestamp: Date.now() });
            },

            // State setters for controlled updates
            setFunds(funds) {
                this.currentFunds = funds;
                currentFunds = funds; // Sync legacy alias
            },

            setGroups(groupList) {
                this.groups = groupList;
                groups = groupList; // Sync legacy alias
                // Update O(1) lookup map
                this.groupsMap.clear();
                groupList.forEach(g => this.groupsMap.set(g.id, g));
                // Clear ancestor cache since groups changed
                this.ancestorCache.clear();
            },

            // O(1) group lookup by ID (synchronous)
            getGroupByIdSync(groupId) {
                return this.groupsMap.get(groupId);
            },

            // Get ancestor group IDs with memoization
            getAncestorIds(groupId) {
                if (this.ancestorCache.has(groupId)) {
                    return this.ancestorCache.get(groupId);
                }
                const ancestors = [];
                let currentId = groupId;
                while (currentId != null) {
                    const group = this.groupsMap.get(currentId);
                    if (!group) break;
                    ancestors.push(group.id);
                    currentId = group.parentId;
                }
                this.ancestorCache.set(groupId, ancestors);
                return ancestors;
            },

            setUnsavedChanges(value) {
                this.hasUnsavedChanges = value;
                hasUnsavedChanges = value; // Sync legacy alias
            },

            setFundNames(names) {
                this.fundNames = names;
                fundNames = names; // Sync legacy alias
            },

            setFundNameData(data) {
                this.fundNameData = data;
                fundNameData = data; // Sync legacy alias
            },

            setSortColumns(columns) {
                this.sortColumns = columns;
                sortColumns = columns; // Sync legacy alias
            },

            setCurrentGroupDescendants(descendants) {
                this.currentGroupDescendants = descendants;
                currentGroupDescendants = descendants; // Sync legacy alias
            }
        };

        // Legacy variable aliases - point to AppState for backward compatibility
        // These will be gradually removed as code is updated to use AppState directly
        let currentFunds = AppState.currentFunds;
        let fundNames = AppState.fundNames;
        let fundNameData = AppState.fundNameData;
        let groups = AppState.groups;
        let currentGroupDescendants = AppState.currentGroupDescendants;
        let sortColumns = AppState.sortColumns;
        let isResizingColumn = AppState.isResizingColumn;
        let lastMousedownOnResizer = AppState.lastMousedownOnResizer;
        let currentActionFundId = AppState.currentActionFundId;
        let currentDetailsFundId = AppState.currentDetailsFundId;
        let hasUnsavedChanges = AppState.hasUnsavedChanges;

        /**
         * Initialize IndexedDB database
         * @returns {Promise<IDBDatabase>} Resolves with database instance
         */
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    dbReady = true;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    const oldVersion = event.oldVersion;
                    const transaction = event.target.transaction;

                    // Funds store
                    if (!db.objectStoreNames.contains(FUNDS_STORE)) {
                        const fundsStore = db.createObjectStore(FUNDS_STORE, {
                            keyPath: 'id',
                            autoIncrement: true
                        });
                        fundsStore.createIndex('fundName', 'fundName', { unique: false });
                        fundsStore.createIndex('accountNumber', 'accountNumber', { unique: false });
                    }

                    // Fund names store
                    if (!db.objectStoreNames.contains(FUNDNAMES_STORE)) {
                        db.createObjectStore(FUNDNAMES_STORE, { keyPath: 'name' });
                    }

                    // Groups store
                    if (!db.objectStoreNames.contains(GROUPS_STORE)) {
                        const groupsStore = db.createObjectStore(GROUPS_STORE, {
                            keyPath: 'id',
                            autoIncrement: true
                        });
                        groupsStore.createIndex('parentGroupId', 'parentGroupId', { unique: false });
                        groupsStore.createIndex('name', 'name', { unique: false });
                    }

                    // Log migration info
                    Debug.log(`Database upgrade from v${oldVersion} to v${DB_VERSION}`);

                    // Migrate from v5 to v6: Move tags from investments to fund names
                    if (oldVersion < 6 && oldVersion >= 5) {
                        // Delete old tags store
                        if (db.objectStoreNames.contains('tags')) {
                            db.deleteObjectStore('tags');
                        }

                        // Get all funds and extract unique fund names with their tags
                        const fundsStore = transaction.objectStore(FUNDS_STORE);
                        const fundNamesStore = transaction.objectStore(FUNDNAMES_STORE);

                        const fundNameTagsMap = new Map(); // fundName -> Set of tags

                        fundsStore.openCursor().onsuccess = function(event) {
                            const cursor = event.target.result;
                            if (cursor) {
                                const fund = cursor.value;
                                if (fund.tags && Array.isArray(fund.tags) && fund.tags.length > 0) {
                                    if (!fundNameTagsMap.has(fund.fundName)) {
                                        fundNameTagsMap.set(fund.fundName, new Set());
                                    }
                                    fund.tags.forEach(tag => fundNameTagsMap.get(fund.fundName).add(tag));
                                }

                                // Remove tags from fund
                                delete fund.tags;
                                cursor.update(fund);

                                cursor.continue();
                            } else {
                                // Cursor finished - now update all fund names with their tags
                                fundNamesStore.getAll().onsuccess = function(event) {
                                    const fundNames = event.target.result;
                                    fundNames.forEach(fundNameObj => {
                                        const name = fundNameObj.name;
                                        const tags = fundNameTagsMap.has(name)
                                            ? Array.from(fundNameTagsMap.get(name))
                                            : [];
                                        fundNamesStore.put({ name, tags });
                                    });
                                };
                            }
                        };
                    }

                    // Migration v7 to v8: No schema changes, just version bump for migration system
                    // Future migrations can be added here using the pattern:
                    // if (oldVersion < 8) {
                    //     // Migration code
                    // }
                };
            });
        }

        // ===========================
        // IndexedDB Helper Wrapper
        // ===========================

        /**
         * IndexedDB helper for common operations
         * @namespace DB
         */
        const DB = {
            /**
             * Execute a transaction operation
             * @param {string} storeName - Object store name
             * @param {string} mode - Transaction mode ('readonly' or 'readwrite')
             * @param {Function} operation - Function that receives the object store
             * @returns {Promise}
             */
            async transaction(storeName, mode, operation) {
                if (!db) {
                    throw new Error('Database not initialized');
                }
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([storeName], mode);
                    const store = transaction.objectStore(storeName);
                    try {
                        const result = operation(store);
                        if (result instanceof IDBRequest) {
                            result.onsuccess = () => resolve(result.result);
                            result.onerror = () => reject(result.error);
                        } else {
                            resolve(result);
                        }
                    } catch (err) {
                        reject(err);
                    }
                });
            },

            /**
             * Get a record by key
             * @param {string} storeName - Object store name
             * @param {*} key - Record key
             * @returns {Promise}
             */
            get(storeName, key) {
                return this.transaction(storeName, 'readonly', store => store.get(key));
            },

            /**
             * Get all records from a store
             * @param {string} storeName - Object store name
             * @returns {Promise<Array>}
             */
            getAll(storeName) {
                return this.transaction(storeName, 'readonly', store => store.getAll());
            },

            /**
             * Put (add/update) a record
             * @param {string} storeName - Object store name
             * @param {Object} data - Data to store
             * @returns {Promise}
             */
            put(storeName, data) {
                return this.transaction(storeName, 'readwrite', store => store.put(data));
            },

            /**
             * Add a new record
             * @param {string} storeName - Object store name
             * @param {Object} data - Data to store
             * @returns {Promise}
             */
            add(storeName, data) {
                return this.transaction(storeName, 'readwrite', store => store.add(data));
            },

            /**
             * Delete a record by key
             * @param {string} storeName - Object store name
             * @param {*} key - Record key
             * @returns {Promise}
             */
            delete(storeName, key) {
                return this.transaction(storeName, 'readwrite', store => store.delete(key));
            }
        };

        function saveFundToDB(fundData) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([FUNDS_STORE], 'readwrite');
                const objectStore = transaction.objectStore(FUNDS_STORE);

                let request;
                if (fundData.id) {
                    request = objectStore.put(fundData);
                } else {
                    delete fundData.id;
                    request = objectStore.add(fundData);
                }

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function getAllFunds() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([FUNDS_STORE], 'readonly');
                const objectStore = transaction.objectStore(FUNDS_STORE);
                const request = objectStore.getAll();

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function getFundById(id) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([FUNDS_STORE], 'readonly');
                const objectStore = transaction.objectStore(FUNDS_STORE);
                const request = objectStore.get(id);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function deleteFundFromDB(id) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([FUNDS_STORE], 'readwrite');
                const objectStore = transaction.objectStore(FUNDS_STORE);
                const request = objectStore.delete(id);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Get all fund name objects (with name and tags)
        function getAllFundNameObjects() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([FUNDNAMES_STORE], 'readonly');
                const objectStore = transaction.objectStore(FUNDNAMES_STORE);
                const request = objectStore.getAll();

                request.onsuccess = () => {
                    // Ensure all objects have required fields with defaults
                    const objects = request.result.map(item => ({
                        name: item.name,
                        tags: item.tags || [],
                        firstCloseDate: item.firstCloseDate || null,
                        finalCloseDate: item.finalCloseDate || null,
                        investmentTermYears: item.investmentTermYears || null
                    }));
                    resolve(objects);
                };
                request.onerror = () => reject(request.error);
            });
        }

        // Get just the fund names (for backward compatibility)
        function getAllFundNames() {
            return new Promise((resolve, reject) => {
                getAllFundNameObjects()
                    .then(objects => resolve(objects.map(obj => obj.name)))
                    .catch(reject);
            });
        }

        // Save or update a fund name (pass string for just name, or object with {name, tags})
        function saveFundName(nameOrObject) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const fundNameObj = typeof nameOrObject === 'string'
                    ? { name: nameOrObject, tags: [] }
                    : {
                        name: nameOrObject.name,
                        tags: nameOrObject.tags || [],
                        firstCloseDate: nameOrObject.firstCloseDate || null,
                        finalCloseDate: nameOrObject.finalCloseDate || null,
                        investmentTermYears: nameOrObject.investmentTermYears || null
                    };

                const transaction = db.transaction([FUNDNAMES_STORE], 'readwrite');
                const objectStore = transaction.objectStore(FUNDNAMES_STORE);
                const request = objectStore.put(fundNameObj);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        function deleteFundName(name) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([FUNDNAMES_STORE], 'readwrite');
                const objectStore = transaction.objectStore(FUNDNAMES_STORE);
                const request = objectStore.delete(name);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // ===========================
        // Groups Database Operations
        // ===========================

        function getAllGroups() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([GROUPS_STORE], 'readonly');
                const objectStore = transaction.objectStore(GROUPS_STORE);
                const request = objectStore.getAll();

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function saveGroup(groupData) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([GROUPS_STORE], 'readwrite');
                const objectStore = transaction.objectStore(GROUPS_STORE);
                const request = objectStore.put(groupData);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function deleteGroup(id) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([GROUPS_STORE], 'readwrite');
                const objectStore = transaction.objectStore(GROUPS_STORE);
                const request = objectStore.delete(id);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        function getGroupsByParent(parentGroupId) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([GROUPS_STORE], 'readonly');
                const objectStore = transaction.objectStore(GROUPS_STORE);
                const index = objectStore.index('parentGroupId');
                const request = index.getAll(parentGroupId);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function getGroupById(id) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([GROUPS_STORE], 'readonly');
                const objectStore = transaction.objectStore(GROUPS_STORE);
                const request = objectStore.get(id);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Get all descendant group IDs recursively with cycle detection
         * @param {number} groupId - Group ID to get descendants for
         * @param {Set} visited - Set of visited group IDs (for cycle detection)
         * @returns {Promise<Array<number>>} Array of descendant group IDs
         */
        async function getAllDescendantGroupIds(groupId, visited = new Set()) {
            // Detect circular reference
            if (visited.has(groupId)) {
                Debug.warn(`Circular reference detected for group ${groupId}`);
                return [];
            }

            visited.add(groupId);
            const descendants = [groupId];

            try {
                const children = await getGroupsByParent(groupId);

                for (const child of children) {
                    const childDescendants = await getAllDescendantGroupIds(child.id, visited);
                    descendants.push(...childDescendants);
                }
            } catch (err) {
                Debug.error('Error getting descendants for group', groupId, err);
            }

            return descendants;
        }

        /**
         * Check if setting parentId for groupId would create a circular reference
         * @param {number} groupId - The group being modified
         * @param {number} parentId - The proposed parent group ID
         * @param {Array} allGroups - All groups in the system
         * @returns {boolean} True if circular reference would be created
         */
        function wouldCreateCircularReference(groupId, parentId, allGroups) {
            if (groupId === parentId) return true;
            if (!parentId) return false;

            // Build a map of group relationships
            const childrenMap = new Map();
            allGroups.forEach(g => {
                if (!childrenMap.has(g.parentGroupId)) {
                    childrenMap.set(g.parentGroupId, []);
                }
                childrenMap.get(g.parentGroupId).push(g.id);
            });

            // Check if parentId is a descendant of groupId
            const visited = new Set();
            const stack = [groupId];

            while (stack.length > 0) {
                const current = stack.pop();

                if (visited.has(current)) continue;
                visited.add(current);

                if (current === parentId) return true; // Circular reference detected

                const children = childrenMap.get(current) || [];
                stack.push(...children);
            }

            return false;
        }

        // ===========================
        // Calculation Functions
        // ===========================

        /**
         * Parse currency string to number with robust error handling and validation
         * @param {string|number|null} val - Value to parse
         * @param {boolean} validate - Whether to validate range (default: true)
         * @returns {number} Parsed number or NaN
         */
        function parseCurrency(val, validate = true) {
            if (val === null || typeof val === 'undefined') return NaN;

            if (typeof val === 'number') {
                if (!isFinite(val)) return NaN;
                if (validate && (val < CONFIG.CURRENCY_MIN || val > CONFIG.CURRENCY_MAX)) {
                    Debug.warn('Currency value out of range:', val);
                    return NaN;
                }
                return val;
            }

            if (typeof val === 'string') {
                const cleaned = val.replace(/[$,]/g, '').replace(/^\((.*)\)$/, '-$1').trim();
                if (cleaned === '' || cleaned === '-') return NaN;
                const num = parseFloat(cleaned);
                if (!isFinite(num)) return NaN;
                if (validate && (num < CONFIG.CURRENCY_MIN || num > CONFIG.CURRENCY_MAX)) {
                    Debug.warn('Currency value out of range:', num);
                    return NaN;
                }
                return num;
            }

            return NaN;
        }

        /**
         * Format number with commas for thousands separator
         * @param {number} num - Number to format
         * @returns {string} Formatted number string
         */
        function formatNumberWithCommas(num) {
            if (num === null || num === undefined || isNaN(num)) return '';
            // Format with commas and up to 2 decimal places if needed
            const parts = num.toString().split('.');
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            return parts.join('.');
        }

        /**
         * Format number as currency using configured locale
         * @param {number|string} value - Value to format
         * @param {boolean} showCents - Whether to show cents (default: false)
         * @returns {string} Formatted currency string
         */
        function formatCurrency(value, showCents = false) {
            const val = parseFloat(value);
            if (!isFinite(val) || isNaN(val)) return '$0';
            return val.toLocaleString(CONFIG.CURRENCY_FORMAT, {
                style: 'currency',
                currency: CONFIG.CURRENCY_CODE,
                minimumFractionDigits: showCents ? 2 : 0,
                maximumFractionDigits: showCents ? 2 : 0
            });
        }

        /**
         * Validate date string format (YYYY-MM-DD) and check for valid date
         * Handles timezone issues by parsing date components directly
         * @param {string} dateStr - Date string to validate
         * @returns {boolean} True if valid date format
         */
        function isValidDate(dateStr) {
            if (typeof dateStr !== 'string' || !CONFIG.DATE_FORMAT.test(dateStr)) {
                return false;
            }

            // Parse date components to avoid timezone issues
            const [year, month, day] = dateStr.split('-').map(Number);

            // Check if date components are valid
            if (month < 1 || month > 12) return false;
            if (day < 1 || day > 31) return false;
            if (year < 1900 || year > 2100) return false;

            // Check if day is valid for the given month
            const daysInMonth = new Date(year, month, 0).getDate();
            if (day > daysInMonth) return false;

            return true;
        }

        /**
         * Parse date string to Date object in UTC to avoid timezone issues
         * @param {string} dateStr - Date string in YYYY-MM-DD format
         * @returns {Date|null} Date object or null if invalid
         */
        function parseDate(dateStr) {
            if (!isValidDate(dateStr)) return null;
            const [year, month, day] = dateStr.split('-').map(Number);
            return new Date(Date.UTC(year, month - 1, day));
        }

        function getVintageYear(fund) {
            const contributions = (fund.cashFlows || [])
                .filter(cf => cf.type === 'Contribution' && isValidDate(cf.date))
                .sort((a, b) => new Date(a.date) - new Date(b.date));

            return contributions.length > 0 ? new Date(contributions[0].date).getFullYear() : null;
        }

        function getTotalByType(fund, type, cutoffDate) {
            return (fund.cashFlows || [])
                .filter(cf =>
                    cf.type === type &&
                    isValidDate(cf.date) &&
                    (!cutoffDate || new Date(cf.date) <= cutoffDate)
                )
                .reduce((sum, cf) => sum + Math.abs(parseCurrency(cf.amount) || 0), 0);
        }

        function getLatestNav(fund, cutoffDate) {
            const navs = (fund.monthlyNav || [])
                .filter(n => isValidDate(n.date) && (!cutoffDate || new Date(n.date) <= cutoffDate))
                .sort((a, b) => new Date(b.date) - new Date(a.date));

            if (navs.length === 0) return 0;

            const latestNav = navs[0];
            let navAmount = parseCurrency(latestNav.amount) || 0;
            const navDate = new Date(latestNav.date);

            // Adjust for cash flows after NAV date
            const subsequentFlows = (fund.cashFlows || []).filter(cf => {
                if (!isValidDate(cf.date)) return false;
                const cfDate = new Date(cf.date);
                return cfDate > navDate && (!cutoffDate || cfDate <= cutoffDate);
            });

            subsequentFlows.forEach(cf => {
                const amount = parseCurrency(cf.amount) || 0;
                if (cf.type === 'Contribution') {
                    navAmount -= Math.abs(amount);
                } else if (cf.type === 'Distribution') {
                    navAmount += Math.abs(amount);
                }
            });

            return navAmount;
        }

        function getOutstandingCommitment(fund, cutoffDate) {
            let outstanding = parseCurrency(fund.commitment) || 0;

            (fund.cashFlows || [])
                .filter(cf =>
                    isValidDate(cf.date) &&
                    (!cutoffDate || new Date(cf.date) <= cutoffDate) &&
                    cf.affectsCommitment !== false
                )
                .forEach(cf => {
                    if (cf.type === 'Contribution') {
                        const amount = parseCurrency(cf.amount) || 0;
                        outstanding -= Math.abs(amount);
                    }
                });

            return Math.max(0, outstanding);
        }

        function parseCashFlowsForIRR(fund, cutoffDate) {
            const flows = (fund.cashFlows || [])
                .filter(cf => isValidDate(cf.date) && (!cutoffDate || new Date(cf.date) <= cutoffDate))
                .map(cf => {
                    const amount = parseCurrency(cf.amount) || 0;
                    return {
                        date: cf.date,
                        amount: cf.type === 'Contribution' ? -Math.abs(amount) : Math.abs(amount)
                    };
                });

            // Add NAV as final cash flow (include zero NAV for accurate IRR calculation)
            const nav = getLatestNav(fund, cutoffDate);
            if (nav >= 0) {
                const navs = (fund.monthlyNav || [])
                    .filter(n => isValidDate(n.date) && (!cutoffDate || new Date(n.date) <= cutoffDate))
                    .sort((a, b) => new Date(b.date) - new Date(a.date));

                if (navs.length > 0) {
                    flows.push({ date: navs[0].date, amount: nav });
                }
            }

            return flows.sort((a, b) => new Date(a.date) - new Date(b.date));
        }

        /**
         * Calculate Internal Rate of Return using Newton-Raphson method
         * Handles edge cases: all positive/negative flows, zero contributions, extreme values
         * @param {Array<{date: string, amount: number}>} cashFlows - Array of cash flows
         * @param {number} guess - Initial guess for IRR (default from CONFIG)
         * @returns {number|null} IRR as decimal or null if calculation fails
         */
        function calculateIRR(cashFlows, guess = CONFIG.IRR_GUESS) {
            if (!Array.isArray(cashFlows) || cashFlows.length < 2) return null;

            // Validate cash flows
            const hasNegative = cashFlows.some(f => f.amount < 0);
            const hasPositive = cashFlows.some(f => f.amount > 0);

            // IRR cannot be calculated if all flows are same sign
            if (!hasNegative || !hasPositive) return null;

            // Check for zero contributions (denominator in MOIC)
            const contributions = cashFlows.filter(f => f.amount < 0).reduce((sum, f) => sum + Math.abs(f.amount), 0);
            if (contributions === 0) return null;

            const flows = [...cashFlows].sort((a, b) => {
                const d1 = parseDate(a.date);
                const d2 = parseDate(b.date);
                return d1 - d2;
            });

            const firstDate = parseDate(flows[0].date);
            if (!firstDate) return null;

            const npv = rate => flows.reduce((acc, cf) => {
                const cfDate = parseDate(cf.date);
                if (!cfDate) return acc;
                const yearsDiff = (cfDate - firstDate) / (365.25 * 24 * 60 * 60 * 1000);
                return acc + cf.amount / Math.pow(1 + rate, yearsDiff);
            }, 0);

            const dNpv = rate => flows.reduce((acc, cf) => {
                const cfDate = parseDate(cf.date);
                if (!cfDate) return acc;
                const yearsDiff = (cfDate - firstDate) / (365.25 * 24 * 60 * 60 * 1000);
                if (yearsDiff === 0) return acc;
                return acc - (yearsDiff * cf.amount) / Math.pow(1 + rate, yearsDiff + 1);
            }, 0);

            let rate = guess;

            for (let i = 0; i < CONFIG.IRR_MAX_ITERATIONS; i++) {
                const npvValue = npv(rate);
                const derivativeValue = dNpv(rate);

                if (Math.abs(npvValue) < CONFIG.IRR_PRECISION) {
                    // Validate result is within reasonable bounds
                    if (rate > CONFIG.IRR_MAX_RATE || rate < CONFIG.IRR_MIN_RATE) return null;
                    return rate;
                }

                // Avoid division by near-zero derivative
                if (Math.abs(derivativeValue) < CONFIG.IRR_PRECISION) return null;

                const newRate = rate - npvValue / derivativeValue;

                // Check convergence
                if (Math.abs(newRate - rate) < CONFIG.IRR_PRECISION) {
                    if (newRate > CONFIG.IRR_MAX_RATE || newRate < CONFIG.IRR_MIN_RATE) return null;
                    return newRate;
                }

                // Prevent rate from going too extreme
                rate = Math.max(CONFIG.IRR_MIN_RATE, Math.min(CONFIG.IRR_MAX_RATE, newRate));
            }

            return null;
        }

        /**
         * Calculate Multiple on Invested Capital (MOIC)
         * @param {Array<{date: string, amount: number}>} cashFlows - Array of cash flows
         * @returns {number|null} MOIC or null if cannot be calculated
         */
        function calculateMOIC(cashFlows) {
            if (!Array.isArray(cashFlows) || cashFlows.length === 0) return null;

            const contributions = cashFlows
                .filter(f => f.amount < 0)
                .reduce((sum, f) => sum + Math.abs(f.amount), 0);

            const distributions = cashFlows
                .filter(f => f.amount > 0)
                .reduce((sum, f) => sum + f.amount, 0);

            // Cannot calculate meaningful MOIC without contributions
            if (contributions === 0) return null;

            const moic = distributions / contributions;

            // Validate MOIC is reasonable (between 0 and 100x)
            if (!isFinite(moic) || moic < 0 || moic > 100) return null;

            return moic;
        }

        /**
         * Calculate Distributed to Paid-In (DPI)
         * DPI = Total Distributions / Total Contributions
         * @param {number} totalDistributions - Sum of all distributions
         * @param {number} totalContributions - Sum of all contributions
         * @returns {number|null} DPI or null if cannot be calculated
         */
        function calculateDPI(totalDistributions, totalContributions) {
            if (totalContributions === 0) return null;
            const dpi = totalDistributions / totalContributions;
            if (!isFinite(dpi) || dpi < 0) return null;
            return dpi;
        }

        /**
         * Calculate Total Value to Paid-In (TVPI)
         * TVPI = (NAV + Total Distributions) / Total Contributions
         * @param {number} nav - Current Net Asset Value
         * @param {number} totalDistributions - Sum of all distributions
         * @param {number} totalContributions - Sum of all contributions
         * @returns {number|null} TVPI or null if cannot be calculated
         */
        function calculateTVPI(nav, totalDistributions, totalContributions) {
            if (totalContributions === 0) return null;
            const tvpi = (nav + totalDistributions) / totalContributions;
            if (!isFinite(tvpi) || tvpi < 0) return null;
            return tvpi;
        }

        /**
         * Calculate Residual Value to Paid-In (RVPI)
         * RVPI = NAV / Total Contributions (unrealized value)
         * @param {number} nav - Current Net Asset Value
         * @param {number} totalContributions - Sum of all contributions
         * @returns {number|null} RVPI or null if cannot be calculated
         */
        function calculateRVPI(nav, totalContributions) {
            if (totalContributions === 0) return null;
            const rvpi = nav / totalContributions;
            if (!isFinite(rvpi) || rvpi < 0) return null;
            return rvpi;
        }

        /**
         * Format DPI/TVPI/RVPI for display
         * @param {number|null} value - DPI or TVPI value
         * @returns {string} Formatted string
         */
        function formatMultiple(value) {
            if (value === null || value === undefined || !isFinite(value)) return 'N/A';
            return value.toFixed(2) + 'x';
        }

        /**
         * Format MOIC for display with consistent null handling
         * @param {number|null} moic - MOIC value
         * @returns {string} Formatted MOIC string
         */
        function formatMOIC(moic) {
            if (moic === null || moic === undefined || !isFinite(moic)) return 'N/A';
            return moic.toFixed(2) + 'x';
        }

        /**
         * Format IRR for display with consistent null handling
         * @param {number|null} irr - IRR value as decimal
         * @returns {string} Formatted IRR string
         */
        function formatIRR(irr) {
            if (irr === null || irr === undefined || !isFinite(irr)) return 'N/A';
            return (irr * 100).toFixed(2) + '%';
        }

        /**
         * Calculate metrics for a fund with caching support
         * @param {Object} fund - Fund object
         * @param {Date|null} cutoffDate - Cutoff date for calculations
         * @param {boolean} useCache - Whether to use cached metrics (default: true)
         * @returns {Object} Calculated metrics
         */
        function calculateMetrics(fund, cutoffDate, useCache = true) {
            // Check cache first
            if (useCache && fund.id) {
                const cached = AppState.getMetricsFromCache(fund.id, cutoffDate);
                if (cached) return cached;
            }

            const commitment = parseCurrency(fund.commitment) || 0;
            const totalContributions = getTotalByType(fund, 'Contribution', cutoffDate);
            const totalDistributions = getTotalByType(fund, 'Distribution', cutoffDate);
            const nav = getLatestNav(fund, cutoffDate);
            const outstandingCommitment = getOutstandingCommitment(fund, cutoffDate);
            const investmentReturn = totalDistributions + nav - totalContributions;
            const vintage = getVintageYear(fund);

            const cashFlowsForIRR = parseCashFlowsForIRR(fund, cutoffDate);
            const irr = calculateIRR(cashFlowsForIRR);
            const moic = calculateMOIC(cashFlowsForIRR);
            const dpi = calculateDPI(totalDistributions, totalContributions);
            const rvpi = calculateRVPI(nav, totalContributions);
            const tvpi = calculateTVPI(nav, totalDistributions, totalContributions);

            const metrics = {
                commitment,
                totalContributions,
                totalDistributions,
                nav,
                outstandingCommitment,
                investmentReturn,
                vintage,
                irr,
                moic,
                dpi,
                rvpi,
                tvpi
            };

            // Cache the result
            if (fund.id) {
                AppState.setMetricsCache(fund.id, cutoffDate, metrics);
            }

            return metrics;
        }

        function getLatestQuarterEnd() {
            const now = new Date();
            const currentMonth = now.getMonth();
            const currentQuarter = Math.floor(currentMonth / 3);
            const quarterStartMonth = currentQuarter * 3;
            return new Date(now.getFullYear(), quarterStartMonth, 0);
        }

        // ===========================
        // Input Validation & Sanitization
        // ===========================

        /**
         * Validate fund name
         * @param {string} name - Fund name to validate
         * @returns {{valid: boolean, error: string|null}} Validation result
         */
        function validateFundName(name) {
            if (!name || typeof name !== 'string') {
                return { valid: false, error: 'Fund name is required' };
            }

            const trimmed = name.trim();

            if (trimmed.length < CONFIG.FUND_NAME_MIN_LENGTH) {
                return { valid: false, error: `Fund name must be at least ${CONFIG.FUND_NAME_MIN_LENGTH} characters` };
            }

            if (trimmed.length > CONFIG.FUND_NAME_MAX_LENGTH) {
                return { valid: false, error: `Fund name must be at most ${CONFIG.FUND_NAME_MAX_LENGTH} characters` };
            }

            if (!CONFIG.ALLOWED_FUND_NAME_PATTERN.test(trimmed)) {
                return { valid: false, error: 'Fund name contains invalid characters. Only letters, numbers, spaces, and basic punctuation allowed.' };
            }

            // Check for potentially dangerous patterns
            const dangerous = ['<script', 'javascript:', 'onerror=', 'onclick='];
            const lowerName = trimmed.toLowerCase();
            for (const pattern of dangerous) {
                if (lowerName.includes(pattern)) {
                    return { valid: false, error: 'Fund name contains invalid pattern' };
                }
            }

            return { valid: true, error: null };
        }

        /**
         * Sanitize text for CSV export to prevent formula injection
         * @param {string} value - Value to sanitize
         * @returns {string} Sanitized value
         */
        function sanitizeForCSV(value) {
            if (value === null || value === undefined) return '';

            const str = String(value);

            // Check if starts with formula injection characters
            if (str.length > 0 && ['=', '+', '-', '@', '\t', '\r'].includes(str[0])) {
                // Prefix with single quote to prevent formula execution
                return "'" + str;
            }

            return str;
        }

        /**
         * Escape CSV value (quote if contains special chars)
         * @param {*} value - Value to escape
         * @returns {string} Escaped CSV value
         */
        function escapeCSV(value) {
            const sanitized = sanitizeForCSV(value);
            if (sanitized === '') return '';

            const str = String(sanitized);
            // If contains comma, quote, or newline, wrap in quotes and escape quotes
            if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                return '"' + str.replace(/"/g, '""') + '"';
            }

            return str;
        }

        /**
         * Validate account number
         * @param {string} accountNumber - Account number to validate
         * @returns {{valid: boolean, error: string|null}} Validation result
         */
        function validateAccountNumber(accountNumber) {
            if (!accountNumber || typeof accountNumber !== 'string') {
                return { valid: false, error: 'Account number is required' };
            }

            const trimmed = accountNumber.trim();

            if (trimmed.length === 0) {
                return { valid: false, error: 'Account number cannot be empty' };
            }

            if (trimmed.length > 100) {
                return { valid: false, error: 'Account number is too long' };
            }

            return { valid: true, error: null };
        }

        /**
         * Validate cash flow data
         * @param {Array} cashFlows - Array of cash flows
         * @returns {{valid: boolean, error: string|null, index: number|null}} Validation result
         */
        function validateCashFlows(cashFlows) {
            if (!Array.isArray(cashFlows)) {
                return { valid: false, error: 'Cash flows must be an array', index: null };
            }

            for (let i = 0; i < cashFlows.length; i++) {
                const cf = cashFlows[i];

                if (!cf.date) {
                    return { valid: false, error: 'Cash flow missing date', index: i };
                }

                if (!isValidDate(cf.date)) {
                    return { valid: false, error: 'Invalid date format (use YYYY-MM-DD)', index: i };
                }

                if (typeof cf.amount === 'undefined') {
                    return { valid: false, error: 'Cash flow missing amount', index: i };
                }

                const amount = parseCurrency(cf.amount);
                if (isNaN(amount)) {
                    return { valid: false, error: 'Invalid amount', index: i };
                }

                if (!['Contribution', 'Distribution'].includes(cf.type)) {
                    return { valid: false, error: 'Invalid cash flow type (must be Contribution or Distribution)', index: i };
                }
            }

            return { valid: true, error: null, index: null };
        }

        /**
         * Validate NAV data
         * @param {Array} monthlyNav - Array of NAV entries
         * @returns {{valid: boolean, error: string|null, index: number|null}} Validation result
         */
        function validateMonthlyNav(monthlyNav) {
            if (!Array.isArray(monthlyNav)) {
                return { valid: false, error: 'Monthly NAV must be an array', index: null };
            }

            for (let i = 0; i < monthlyNav.length; i++) {
                const nav = monthlyNav[i];

                if (!nav.date) {
                    return { valid: false, error: 'NAV entry missing date', index: i };
                }

                if (!isValidDate(nav.date)) {
                    return { valid: false, error: 'Invalid date format (use YYYY-MM-DD)', index: i };
                }

                if (typeof nav.amount === 'undefined') {
                    return { valid: false, error: 'NAV entry missing amount', index: i };
                }

                const amount = parseCurrency(nav.amount);
                if (isNaN(amount)) {
                    return { valid: false, error: 'Invalid NAV amount', index: i };
                }

                if (amount < 0) {
                    return { valid: false, error: 'NAV amount cannot be negative', index: i };
                }
            }

            return { valid: true, error: null, index: null };
        }

        // ===========================
        // UI Functions
        // ===========================

        function showStatus(message, type = 'success') {
            const statusDiv = document.createElement('div');
            statusDiv.className = `status-message ${type}`;

            // Create close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-status';
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = () => statusDiv.remove();

            // Create message text
            const messageText = document.createElement('span');
            messageText.textContent = message;

            statusDiv.appendChild(messageText);
            statusDiv.appendChild(closeBtn);
            document.body.appendChild(statusDiv);

            // Auto-dismiss messages: success after 3s, errors/warnings after 8s
            const dismissTime = type === 'success' ? 3000 : 8000;
            setTimeout(() => {
                if (statusDiv.parentNode) {
                    statusDiv.remove();
                }
            }, dismissTime);
        }

        function showLoading(message = 'Loading...') {
            const overlay = document.getElementById('loadingOverlay');
            const text = document.getElementById('loadingText');
            text.textContent = message;
            overlay.classList.add('show');
        }

        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.remove('show');
        }

        async function renderTable() {
            try {
                const funds = await getAllFunds();
                AppState.setFunds(funds);

                // Apply filters
                let filtered = applyCurrentFilters(funds);

                // Apply sorting
                if (sortColumns.length > 0) {
                    filtered = sortData(filtered, sortColumns);
                }

                // Update filter dropdowns bidirectionally
                // Each dropdown shows only options compatible with other selected filters
                updateFilterDropdowns(funds);

                // Update active filters indicator
                updateActiveFiltersIndicator();

                // Get cutoff date
                const cutoffDateValue = document.getElementById('cutoffDate').value;
                const cutoffDate = cutoffDateValue ? new Date(cutoffDateValue) : null;

                // Calculate metrics for each fund
                const fundsWithMetrics = filtered.map(fund => ({
                    ...fund,
                    metrics: calculateMetrics(fund, cutoffDate)
                }));

                // Update portfolio summary statistics
                updatePortfolioSummary(fundsWithMetrics, cutoffDate);

                // Render cash flow timeline (uses filtered funds)
                renderTimelineTable(filtered);

                // Render table body
                const tbody = document.getElementById('fundsTableBody');
                tbody.innerHTML = '';

                if (fundsWithMetrics.length === 0) {
                    // Check if this is due to filters or no data at all
                    const hasFilters = document.getElementById('fundFilter').value ||
                        document.getElementById('accountFilter').value ||
                        document.getElementById('groupFilter').value ||
                        document.getElementById('searchInput').value ||
                        document.getElementById('vintageFilter').value;

                    const hasAnyFunds = currentFunds.length > 0;

                    let emptyStateHtml;
                    if (hasFilters && hasAnyFunds) {
                        emptyStateHtml = `
                            <tr>
                                <td colspan="12" class="empty-state">
                                    <div style="padding: 40px;">
                                        <h3 style="margin-bottom: 10px;">No matching investments</h3>
                                        <p style="margin-bottom: 15px;">No investments match your current filters.</p>
                                        <button type="button" class="btn-secondary" onclick="resetFilters()">Clear All Filters</button>
                                    </div>
                                </td>
                            </tr>
                        `;
                    } else {
                        emptyStateHtml = `
                            <tr>
                                <td colspan="12" class="empty-state">
                                    <div style="padding: 40px;">
                                        <h3 style="margin-bottom: 10px;">No investments yet</h3>
                                        <p style="margin-bottom: 15px;">Add your first investment to start tracking your portfolio.</p>
                                        <button type="button" class="btn-primary" onclick="showAddFundModal()">Add Investment</button>
                                    </div>
                                </td>
                            </tr>
                        `;
                    }
                    tbody.innerHTML = emptyStateHtml;
                    return;
                }

                fundsWithMetrics.forEach((fund, index) => {
                    const m = fund.metrics;
                    const row = document.createElement('tr');

                    // Add keyboard navigation attributes
                    row.setAttribute('tabindex', '0');
                    row.setAttribute('data-fund-id', fund.id);
                    row.setAttribute('role', 'row');
                    row.setAttribute('aria-rowindex', index + 2); // +2 for header row

                    // Build tags HTML - look up tags from fund name
                    const showTags = document.getElementById('sidebarShowTagsCheckbox').checked;
                    const fundNameObj = fundNameData.get(fund.fundName);
                    const tags = fundNameObj && fundNameObj.tags ? fundNameObj.tags : [];
                    const tagsHtml = (showTags && tags.length > 0)
                        ? `<div class="table-tags">${tags.map(tag => `<span class="table-tag">${escapeHtml(tag)}</span>`).join('')}</div>`
                        : '';

                    row.innerHTML = `
                        <td>
                            <div>${escapeHtml(fund.fundName)}</div>
                            ${tagsHtml}
                        </td>
                        <td title="${escapeHtml(getParentAccountDisplay(fund))}">${getInvestorCellHtml(fund)}</td>
                        <td class="center">${m.vintage || 'N/A'}</td>
                        <td class="number">${formatCurrency(m.commitment)}</td>
                        <td class="number">${formatCurrency(m.totalContributions)}</td>
                        <td class="number">${formatCurrency(m.totalDistributions)}</td>
                        <td class="number">${formatCurrency(m.nav)}</td>
                        <td class="number ${m.investmentReturn >= 0 ? 'positive' : 'negative'}">${formatCurrency(m.investmentReturn)}</td>
                        <td class="number">${formatMOIC(m.moic)}</td>
                        <td class="number ${m.irr !== null && m.irr >= 0 ? 'positive' : 'negative'}">${formatIRR(m.irr)}</td>
                        <td class="number">${formatCurrency(m.outstandingCommitment)}</td>
                        <td class="center">
                            <button class="btn-icon fund-actions-btn" data-fund-id="${fund.id}" title="Actions">⚙</button>
                        </td>
                    `;

                    tbody.appendChild(row);
                });

                // Add totals row
                addTotalsRow(fundsWithMetrics, cutoffDate);

            } catch (err) {
                Debug.error('Error rendering table:', err);
                showStatus('Error loading data: ' + err.message, 'error');
            }
        }

        function addTotalsRow(fundsWithMetrics, cutoffDate) {
            const tbody = document.getElementById('fundsTableBody');

            // Calculate totals
            const totals = {
                commitment: 0,
                totalContributions: 0,
                totalDistributions: 0,
                nav: 0,
                investmentReturn: 0,
                outstandingCommitment: 0,
                aggregateFlows: []
            };

            fundsWithMetrics.forEach(fund => {
                const m = fund.metrics;
                totals.commitment += m.commitment;
                totals.totalContributions += m.totalContributions;
                totals.totalDistributions += m.totalDistributions;
                totals.nav += m.nav;
                totals.investmentReturn += m.investmentReturn;
                totals.outstandingCommitment += m.outstandingCommitment;

                const flows = parseCashFlowsForIRR(fund, cutoffDate);
                totals.aggregateFlows.push(...flows);
            });

            // Calculate aggregate IRR and MOIC
            const aggregateIRR = calculateIRR(totals.aggregateFlows);
            const aggregateMOIC = calculateMOIC(totals.aggregateFlows);

            const totalRow = document.createElement('tr');
            totalRow.innerHTML = `
                <td><strong>Total</strong></td>
                <td></td>
                <td></td>
                <td class="number"><strong>${formatCurrency(totals.commitment)}</strong></td>
                <td class="number"><strong>${formatCurrency(totals.totalContributions)}</strong></td>
                <td class="number"><strong>${formatCurrency(totals.totalDistributions)}</strong></td>
                <td class="number"><strong>${formatCurrency(totals.nav)}</strong></td>
                <td class="number ${totals.investmentReturn >= 0 ? 'positive' : 'negative'}"><strong>${formatCurrency(totals.investmentReturn)}</strong></td>
                <td class="number"><strong>${formatMOIC(aggregateMOIC)}</strong></td>
                <td class="number ${aggregateIRR !== null && aggregateIRR >= 0 ? 'positive' : 'negative'}"><strong>${formatIRR(aggregateIRR)}</strong></td>
                <td class="number"><strong>${formatCurrency(totals.outstandingCommitment)}</strong></td>
                <td></td>
            `;

            tbody.appendChild(totalRow);
        }

        function applyCurrentFilters(funds) {
            // Get filter values once (cached for all funds)
            const filterValues = {
                fundFilter: document.getElementById('fundFilter').value,
                accountFilter: document.getElementById('accountFilter').value,
                groupFilter: document.getElementById('groupFilter').value,
                searchInput: document.getElementById('searchInput').value.toLowerCase().trim(),
                vintageFilter: document.getElementById('vintageFilter').value
            };

            return funds.filter(fund => {
                // Apply declarative filters from FilterConfigs
                for (const config of FilterConfigs) {
                    const value = filterValues[config.id];
                    if (!config.apply(fund, value)) return false;
                }

                // Group filter (special handling for hierarchical groups)
                if (filterValues.groupFilter) {
                    const groupId = parseInt(filterValues.groupFilter);
                    if (!fund.groupId) return false;
                    if (!currentGroupDescendants || currentGroupDescendants.groupId !== groupId) {
                        return false; // Will be set by async filter
                    }
                    if (!currentGroupDescendants.ids.includes(fund.groupId)) return false;
                }

                // Tags search (extends searchInput to include tags)
                if (filterValues.searchInput) {
                    const fundNameObj = fundNameData.get(fund.fundName);
                    const tags = fundNameObj && fundNameObj.tags ? fundNameObj.tags : [];
                    const fundTags = tags.map(tag => tag.toLowerCase()).join(' ');
                    // If search already matched via FilterConfigs, pass; otherwise check tags
                    if (!fund.fundName.toLowerCase().includes(filterValues.searchInput) &&
                        !(fund.accountNumber && fund.accountNumber.toLowerCase().includes(filterValues.searchInput)) &&
                        !fundTags.includes(filterValues.searchInput)) {
                        return false;
                    }
                }

                return true;
            });
        }

        function updateFilterDropdowns(allFunds) {
            // Get current filter values
            const groupFilter = document.getElementById('groupFilter');
            const fundFilter = document.getElementById('fundFilter');
            const accountFilter = document.getElementById('accountFilter');
            const vintageFilter = document.getElementById('vintageFilter');

            const currentGroupValue = groupFilter.value;
            const currentFundValue = fundFilter.value;
            const currentAccountValue = accountFilter.value;
            const currentVintageValue = vintageFilter.value;

            // Helper function to filter funds by group
            const filterByGroup = (funds, groupId) => {
                if (!groupId) return funds;
                const gId = parseInt(groupId);
                return funds.filter(fund => {
                    if (!fund.groupId) return false;
                    if (fund.groupId === gId) return true;
                    // Check if fund's group is descendant of selected group
                    if (currentGroupDescendants && currentGroupDescendants.groupId === gId) {
                        return currentGroupDescendants.ids.includes(fund.groupId);
                    }
                    return false;
                });
            };

            // Helper function to filter funds by vintage
            const filterByVintage = (funds, vintage) => {
                if (!vintage) return funds;
                const vintageYear = parseInt(vintage);
                return funds.filter(fund => getVintageYear(fund) === vintageYear);
            };

            // 1. Update FUND dropdown (filter by group, account, and vintage)
            let fundsForFundDropdown = allFunds;
            if (currentGroupValue) {
                fundsForFundDropdown = filterByGroup(fundsForFundDropdown, currentGroupValue);
            }
            if (currentAccountValue) {
                fundsForFundDropdown = fundsForFundDropdown.filter(f => f.accountNumber === currentAccountValue);
            }
            if (currentVintageValue) {
                fundsForFundDropdown = filterByVintage(fundsForFundDropdown, currentVintageValue);
            }
            const uniqueFunds = [...new Set(fundsForFundDropdown.map(f => f.fundName))].sort();
            fundFilter.innerHTML = '<option value="">All Funds</option>';
            uniqueFunds.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                fundFilter.appendChild(option);
            });
            if (currentFundValue && uniqueFunds.includes(currentFundValue)) {
                fundFilter.value = currentFundValue;
            } else {
                fundFilter.value = '';
            }

            // 2. Update ACCOUNT dropdown (filter by group, fund, and vintage)
            let fundsForAccountDropdown = allFunds;
            if (currentGroupValue) {
                fundsForAccountDropdown = filterByGroup(fundsForAccountDropdown, currentGroupValue);
            }
            if (currentFundValue) {
                fundsForAccountDropdown = fundsForAccountDropdown.filter(f => f.fundName === currentFundValue);
            }
            if (currentVintageValue) {
                fundsForAccountDropdown = filterByVintage(fundsForAccountDropdown, currentVintageValue);
            }
            const uniqueAccounts = [...new Set(fundsForAccountDropdown.map(f => f.accountNumber))].sort();
            accountFilter.innerHTML = '<option value="">All Accounts</option>';
            uniqueAccounts.forEach(account => {
                const option = document.createElement('option');
                option.value = account;
                option.textContent = account;
                accountFilter.appendChild(option);
            });
            if (currentAccountValue && uniqueAccounts.includes(currentAccountValue)) {
                accountFilter.value = currentAccountValue;
            } else {
                accountFilter.value = '';
            }

            // 3. Update GROUP dropdown
            groupFilter.innerHTML = '<option value="">All Groups</option>';
            if (groups.length > 0) {
                const tree = buildGroupsTree(groups, null);

                // If a group is already selected, keep it selected and show all groups
                // Group filter takes priority and should not be auto-cleared
                if (currentGroupValue) {
                    addGroupOptionsToSelect(groupFilter, tree, 0);
                    groupFilter.value = currentGroupValue;
                } else if (currentFundValue || currentAccountValue || currentVintageValue) {
                    // Only filter groups when NO group is selected but fund/account/vintage IS selected
                    // This helps users see which groups contain the selected fund/account/vintage
                    let fundsForGroupDropdown = allFunds;
                    if (currentFundValue) {
                        fundsForGroupDropdown = fundsForGroupDropdown.filter(f => f.fundName === currentFundValue);
                    }
                    if (currentAccountValue) {
                        fundsForGroupDropdown = fundsForGroupDropdown.filter(f => f.accountNumber === currentAccountValue);
                    }
                    if (currentVintageValue) {
                        fundsForGroupDropdown = filterByVintage(fundsForGroupDropdown, currentVintageValue);
                    }

                    // Collect all group IDs including ancestors
                    const validGroupIds = new Set();
                    fundsForGroupDropdown.forEach(fund => {
                        if (fund.groupId != null) {
                            // Add the fund's group and all its ancestors
                            const ancestors = getAncestorGroupIds(fund.groupId);
                            ancestors.forEach(id => validGroupIds.add(id));
                        }
                    });

                    addGroupOptionsToSelectFiltered(groupFilter, tree, 0, validGroupIds);
                } else {
                    // No filters active - show all groups
                    addGroupOptionsToSelect(groupFilter, tree, 0);
                }
            }

            // 4. Update VINTAGE dropdown (filter by group, fund, and account)
            let fundsForVintageDropdown = allFunds;
            if (currentGroupValue) {
                fundsForVintageDropdown = filterByGroup(fundsForVintageDropdown, currentGroupValue);
            }
            if (currentFundValue) {
                fundsForVintageDropdown = fundsForVintageDropdown.filter(f => f.fundName === currentFundValue);
            }
            if (currentAccountValue) {
                fundsForVintageDropdown = fundsForVintageDropdown.filter(f => f.accountNumber === currentAccountValue);
            }

            // Get unique vintage years from filtered funds
            const vintages = new Set();
            fundsForVintageDropdown.forEach(fund => {
                const vintage = getVintageYear(fund);
                if (vintage) {
                    vintages.add(vintage);
                }
            });
            const sortedVintages = Array.from(vintages).sort((a, b) => b - a);

            vintageFilter.innerHTML = '<option value="">All Vintages</option>';
            sortedVintages.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                vintageFilter.appendChild(option);
            });

            // Restore selection if still valid
            if (currentVintageValue && sortedVintages.includes(parseInt(currentVintageValue))) {
                vintageFilter.value = currentVintageValue;
            } else if (currentVintageValue) {
                // Selection no longer valid, clear it
                vintageFilter.value = '';
            }
        }

        // Helper function to get all ancestor group IDs (uses memoized AppState version)
        function getAncestorGroupIds(groupId) {
            return AppState.getAncestorIds(groupId);
        }

        // Helper function to get immediate parent group name for a fund (O(1) lookup)
        function getImmediateParentName(fund) {
            if (!fund.groupId) return '';
            const group = AppState.getGroupByIdSync(fund.groupId);
            return group ? group.name : '';
        }

        // Helper function to get parent name + account display text (for sorting/tooltips)
        function getParentAccountDisplay(fund) {
            const parentName = getImmediateParentName(fund);
            return parentName ? `${parentName} (${fund.accountNumber})` : fund.accountNumber;
        }

        // Helper function to get HTML for investor cell display
        function getInvestorCellHtml(fund) {
            const groupName = getImmediateParentName(fund);
            if (groupName) {
                return `<div>${escapeHtml(groupName)}</div><div style="font-size: 0.85em; color: #7f8c8d;">${escapeHtml(fund.accountNumber)}</div>`;
            }
            return escapeHtml(fund.accountNumber);
        }

        // Helper function to add group options but only include groups with valid funds
        function addGroupOptionsToSelectFiltered(selectElement, groupNodes, level, validGroupIds) {
            groupNodes.forEach(node => {
                // Only add this group if it or any of its descendants are in validGroupIds
                const hasValidFunds = validGroupIds.has(node.id) ||
                    hasDescendantWithValidFunds(node, validGroupIds);

                if (hasValidFunds) {
                    const option = document.createElement('option');
                    option.value = node.id;
                    // Use increasing dashes to show hierarchy depth
                    const prefix = level > 0 ? '–'.repeat(level) + ' ' : '';
                    option.textContent = prefix + node.name;
                    selectElement.appendChild(option);

                    if (node.children.length > 0) {
                        addGroupOptionsToSelectFiltered(selectElement, node.children, level + 1, validGroupIds);
                    }
                }
            });
        }

        // Check if a group node or any of its descendants have valid funds
        function hasDescendantWithValidFunds(node, validGroupIds) {
            if (validGroupIds.has(node.id)) return true;
            for (const child of node.children) {
                if (hasDescendantWithValidFunds(child, validGroupIds)) return true;
            }
            return false;
        }

        /**
         * Apply filters to the funds table with race condition protection
         * @returns {Promise<void>}
         */
        async function applyFilters() {
            // Cancel any in-flight filter operation
            if (AppState.abortController) {
                AppState.abortController.abort();
            }

            // Create new abort controller for this operation
            AppState.abortController = new AbortController();
            const signal = AppState.abortController.signal;

            // Show loading indicator
            setFilterLoading(true);

            try {
                const groupFilterValue = document.getElementById('groupFilter').value;

                // Check if cancelled
                if (signal.aborted) return;

                // Precompute descendants if group filter is active
                if (groupFilterValue) {
                    const groupId = parseInt(groupFilterValue);

                    // Use cached descendants if available and valid
                    if (!AppState.groupDescendantsCache.has(groupId)) {
                        const descendants = await getAllDescendantGroupIds(groupId);
                        if (signal.aborted) return; // Check again after async operation
                        AppState.groupDescendantsCache.set(groupId, descendants);
                    }

                    AppState.setCurrentGroupDescendants({
                        groupId,
                        ids: AppState.groupDescendantsCache.get(groupId)
                    });
                } else {
                    AppState.setCurrentGroupDescendants(null);
                }

                if (signal.aborted) return;

                // Update header based on selected group
                updateHeader();

                if (signal.aborted) return;

                await renderTable();

                // Announce results to screen readers
                const fundCount = document.getElementById('summaryFundCount').textContent;
                announceToScreenReader(`Filter applied. Showing ${fundCount} funds.`);
            } catch (err) {
                if (err.name === 'AbortError') {
                    // Operation was cancelled, ignore
                    return;
                }
                Debug.error('Error applying filters:', err);
                showStatus('Error applying filters: ' + err.message, 'error');
            } finally {
                // Hide loading indicator
                setFilterLoading(false);
                // Clear abort controller if this is still the current one
                if (AppState.abortController && !AppState.abortController.signal.aborted) {
                    AppState.abortController = null;
                }
            }
        }

        /**
         * Debounced version of applyFilters to reduce excessive calls
         * @const {Function}
         */
        const applyFiltersDebounced = debounce(applyFilters, CONFIG.DEBOUNCE_FILTER);

        function updateHeader() {
            const groupFilterValue = document.getElementById('groupFilter').value;
            const headerTitle = document.getElementById('headerTitle');
            const headerSubtitle = document.getElementById('headerSubtitle');

            if (groupFilterValue) {
                const groupId = parseInt(groupFilterValue);
                const group = AppState.getGroupByIdSync(groupId);

                if (group) {
                    // Set main title to group name
                    headerTitle.textContent = group.name;

                    // Set subtitle to parent group name if exists, otherwise hide subtitle for top-level groups
                    if (group.parentGroupId) {
                        const parentGroup = AppState.getGroupByIdSync(group.parentGroupId);
                        if (parentGroup) {
                            headerSubtitle.textContent = parentGroup.name;
                        } else {
                            headerSubtitle.textContent = group.type || 'Account Group';
                        }
                    } else {
                        // Top level group - no subtitle
                        headerSubtitle.textContent = '';
                    }
                }
            } else {
                // Reset to default
                headerTitle.textContent = 'PE Fund Manager';
                headerSubtitle.textContent = 'Private Equity Fund Analytics & Management Tool';
            }
        }

        async function resetFilters() {
            document.getElementById('fundFilter').value = '';
            document.getElementById('accountFilter').value = '';
            document.getElementById('groupFilter').value = '';
            document.getElementById('searchInput').value = '';
            document.getElementById('vintageFilter').value = '';

            // Reset cutoff date to latest quarter end (same as page load)
            const quarterEnd = getLatestQuarterEnd();
            document.getElementById('cutoffDate').value = quarterEnd.toISOString().split('T')[0];

            // Clear all sort columns
            AppState.setSortColumns([]);
            updateSortHeaders();

            AppState.setCurrentGroupDescendants(null);
            updateHeader();
            updateActiveFiltersIndicator();
            await renderTable();

            announceToScreenReader('All filters have been reset.');
        }

        /**
         * Update the active filters indicator
         */
        function updateActiveFiltersIndicator() {
            const fundFilter = document.getElementById('fundFilter').value;
            const accountFilter = document.getElementById('accountFilter').value;
            const groupFilter = document.getElementById('groupFilter').value;
            const searchInput = document.getElementById('searchInput').value.trim();
            const vintageFilter = document.getElementById('vintageFilter').value;

            // Count active filters
            let filterCount = 0;
            if (fundFilter) filterCount++;
            if (accountFilter) filterCount++;
            if (groupFilter) filterCount++;
            if (searchInput) filterCount++;
            if (vintageFilter) filterCount++;

            const indicator = document.getElementById('activeFiltersIndicator');

            if (indicator) {
                if (filterCount > 0) {
                    indicator.style.display = 'inline-flex';
                    indicator.innerHTML = `${filterCount} filter${filterCount > 1 ? 's' : ''} <button class="clear-filters" title="Clear all filters" aria-label="Clear all filters">&times;</button>`;
                    // Attach event listener to the clear button
                    const clearBtn = indicator.querySelector('.clear-filters');
                    if (clearBtn) {
                        clearBtn.onclick = function(e) {
                            e.stopPropagation();
                            resetFilters();
                        };
                    }
                } else {
                    indicator.style.display = 'none';
                    indicator.innerHTML = '';
                }
            }
        }

        /**
         * Update portfolio summary statistics
         * @param {Array} fundsWithMetrics - Array of funds with calculated metrics
         * @param {Date|null} cutoffDate - Cutoff date for calculations
         */
        function updatePortfolioSummary(fundsWithMetrics, cutoffDate) {
            const count = fundsWithMetrics.length;

            // Calculate totals
            let totalCommitment = 0;
            let totalNav = 0;
            let totalContributions = 0;
            let totalDistributions = 0;
            let validIRRs = [];
            let validMOICs = [];
            let aggregateFlows = [];

            fundsWithMetrics.forEach(fund => {
                const m = fund.metrics;
                totalCommitment += m.commitment || 0;
                totalNav += m.nav || 0;
                totalContributions += m.totalContributions || 0;
                totalDistributions += m.totalDistributions || 0;

                if (m.irr !== null && isFinite(m.irr)) {
                    validIRRs.push(m.irr);
                }
                if (m.moic !== null && isFinite(m.moic)) {
                    validMOICs.push(m.moic);
                }

                // Collect cash flows for aggregate calculations
                const flows = parseCashFlowsForIRR(fund, cutoffDate);
                aggregateFlows.push(...flows);
            });

            // Calculate averages
            const avgIRR = validIRRs.length > 0
                ? validIRRs.reduce((a, b) => a + b, 0) / validIRRs.length
                : null;
            const avgMOIC = validMOICs.length > 0
                ? validMOICs.reduce((a, b) => a + b, 0) / validMOICs.length
                : null;

            // Calculate aggregate DPI, RVPI, and TVPI
            const portfolioDPI = calculateDPI(totalDistributions, totalContributions);
            const portfolioRVPI = calculateRVPI(totalNav, totalContributions);
            const portfolioTVPI = calculateTVPI(totalNav, totalDistributions, totalContributions);

            // Update DOM
            document.getElementById('summaryFundCount').textContent = count;
            document.getElementById('summaryCommitment').textContent = formatCurrency(totalCommitment);
            document.getElementById('summaryNav').textContent = formatCurrency(totalNav);

            const irrElement = document.getElementById('summaryIRR');
            irrElement.textContent = formatIRR(avgIRR);
            irrElement.className = 'summary-value' + (avgIRR !== null ? (avgIRR >= 0 ? ' positive' : ' negative') : '');

            const moicElement = document.getElementById('summaryMOIC');
            moicElement.textContent = formatMOIC(avgMOIC);
            moicElement.className = 'summary-value' + (avgMOIC !== null ? (avgMOIC >= 1 ? ' positive' : ' negative') : '');

            const dpiElement = document.getElementById('summaryDPI');
            dpiElement.textContent = formatMultiple(portfolioDPI);
            dpiElement.className = 'summary-value' + (portfolioDPI !== null ? (portfolioDPI >= 1 ? ' positive' : '') : '');

            const rvpiElement = document.getElementById('summaryRVPI');
            rvpiElement.textContent = formatMultiple(portfolioRVPI);
            rvpiElement.className = 'summary-value';

            const tvpiElement = document.getElementById('summaryTVPI');
            tvpiElement.textContent = formatMultiple(portfolioTVPI);
            tvpiElement.className = 'summary-value' + (portfolioTVPI !== null ? (portfolioTVPI >= 1 ? ' positive' : ' negative') : '');
        }

        /**
         * Toggle dark mode
         */
        // ===========================
        // Cash Flow Timeline Functions
        // ===========================

        /**
         * Aggregate historical cash flows by year
         * @param {Array} funds - Array of fund objects
         * @param {Date|null} cutoffDate - Cutoff date for separating historical from projected
         * @returns {Object} { calls: {year: amount}, distributions: {year: amount}, byFund: {...} }
         */
        function aggregateHistoricalCashFlows(funds, cutoffDate) {
            const result = {
                calls: {},
                distributions: {},
                byFund: {}
            };

            // Use cutoff date if provided, otherwise use current date
            const cutoffYear = cutoffDate ? cutoffDate.getFullYear() : new Date().getFullYear();

            funds.forEach(fund => {
                if (!fund.cashFlows || fund.cashFlows.length === 0) return;

                const fundKey = fund.fundName;
                if (!result.byFund[fundKey]) {
                    result.byFund[fundKey] = { calls: {}, distributions: {} };
                }

                fund.cashFlows.forEach(cf => {
                    const cfDate = new Date(cf.date);
                    const year = cfDate.getFullYear();

                    // Only include historical data (on or before cutoff date)
                    if (cutoffDate && cfDate > cutoffDate) return;
                    if (year > cutoffYear) return;

                    const amount = Math.abs(cf.amount);

                    if (cf.amount < 0 || cf.type === 'Contribution') {
                        // Capital call (contribution)
                        result.calls[year] = (result.calls[year] || 0) + amount;
                        result.byFund[fundKey].calls[year] = (result.byFund[fundKey].calls[year] || 0) + amount;
                    } else {
                        // Distribution
                        result.distributions[year] = (result.distributions[year] || 0) + amount;
                        result.byFund[fundKey].distributions[year] = (result.byFund[fundKey].distributions[year] || 0) + amount;
                    }
                });
            });

            return result;
        }

        /**
         * Calculate projected capital calls by year for a set of funds
         * @param {Array} funds - Array of fund objects
         * @param {Map} fundNameData - Map of fund name to fund name object (with terms)
         * @param {Date|null} cutoffDate - Cutoff date for separating historical from projected
         * @returns {Object} { projectedCalls: {year: amount}, byFund: {fundName: {year: amount}} }
         */
        function calculateProjectedCalls(funds, fundNameData, cutoffDate) {
            const result = {
                projectedCalls: {},
                byFund: {}
            };

            // Use cutoff date if provided, otherwise use current date
            const referenceDate = cutoffDate || new Date();
            const referenceYear = referenceDate.getFullYear();

            funds.forEach(fund => {
                const fundNameObj = fundNameData.get(fund.fundName);
                if (!fundNameObj) return;

                const { finalCloseDate, investmentTermYears } = fundNameObj;

                // Skip if missing required fund terms
                if (!finalCloseDate || !investmentTermYears) return;

                // Calculate investment period end
                const finalClose = new Date(finalCloseDate);
                const investmentEndDate = new Date(finalClose);
                investmentEndDate.setFullYear(investmentEndDate.getFullYear() + investmentTermYears);

                // Skip if investment period has ended relative to cutoff date
                if (investmentEndDate < referenceDate) return;

                // Calculate remaining uncalled capital as of cutoff date
                const commitment = fund.commitment || 0;
                const totalCalled = (fund.cashFlows || [])
                    .filter(cf => {
                        // Only count contributions on or before cutoff date
                        if (cutoffDate && new Date(cf.date) > cutoffDate) return false;
                        return cf.amount < 0 || cf.type === 'Contribution';
                    })
                    .reduce((sum, cf) => sum + Math.abs(cf.amount), 0);
                const uncalledCapital = Math.max(0, commitment - totalCalled);

                if (uncalledCapital <= 0) return;

                // Calculate years remaining in investment period (starting after cutoff year)
                const startYear = Math.max(referenceYear + 1, finalClose.getFullYear());
                const endYear = investmentEndDate.getFullYear();
                const yearsRemaining = [];

                for (let year = startYear; year <= endYear; year++) {
                    yearsRemaining.push(year);
                }

                if (yearsRemaining.length === 0) return;

                // Distribute uncalled capital linearly across remaining years
                const annualCall = uncalledCapital / yearsRemaining.length;

                const fundKey = fund.fundName;
                if (!result.byFund[fundKey]) {
                    result.byFund[fundKey] = {};
                }

                yearsRemaining.forEach(year => {
                    result.projectedCalls[year] = (result.projectedCalls[year] || 0) + annualCall;
                    result.byFund[fundKey][year] = (result.byFund[fundKey][year] || 0) + annualCall;
                });
            });

            return result;
        }

        /**
         * Get the range of years to display in the timeline
         * @param {Object} historical - Historical cash flow data
         * @param {Object} projected - Projected call data
         * @param {number|null} cutoffYear - The cutoff year (last historical year)
         * @returns {Object} { years: [], cutoffYear: number, firstProjectedYear: number }
         */
        function getTimelineYearRange(historical, projected, cutoffYear) {
            // Use cutoff year if provided, otherwise use current year
            const dividerYear = cutoffYear || new Date().getFullYear();

            // Collect all years that have data
            const dataYears = new Set();
            Object.keys(historical.calls).forEach(y => dataYears.add(parseInt(y)));
            Object.keys(historical.distributions).forEach(y => dataYears.add(parseInt(y)));
            Object.keys(projected.projectedCalls).forEach(y => dataYears.add(parseInt(y)));

            // Find the min and max years with data
            const yearsWithData = Array.from(dataYears);
            if (yearsWithData.length === 0) {
                // No data, show cutoff year and next 4 years
                const years = [];
                for (let y = dividerYear; y <= dividerYear + 4; y++) {
                    years.push(y);
                }
                return { years, cutoffYear: dividerYear, firstProjectedYear: dividerYear + 1 };
            }

            const minDataYear = Math.min(...yearsWithData);
            const maxDataYear = Math.max(...yearsWithData);

            // Determine display range:
            // Historical: from minDataYear to cutoffYear (at least 5 years back from cutoff if data exists)
            // Projected: from cutoffYear+1 to at least 5 years out or maxDataYear
            const historicalStart = Math.min(minDataYear, dividerYear - 4);
            const projectedEnd = Math.max(maxDataYear, dividerYear + 5);

            // Build continuous year range
            const years = [];
            for (let y = historicalStart; y <= projectedEnd; y++) {
                years.push(y);
            }

            // Limit to reasonable display (last 5 historical + next 5 projected = 10 years max)
            const historicalYears = years.filter(y => y <= dividerYear);
            const projectedYears = years.filter(y => y > dividerYear);

            const displayHistorical = historicalYears.slice(-5);
            const displayProjected = projectedYears.slice(0, 5);

            return {
                years: [...displayHistorical, ...displayProjected],
                cutoffYear: dividerYear,
                firstProjectedYear: displayProjected.length > 0 ? displayProjected[0] : null
            };
        }

        /**
         * Render the cash flow timeline table
         * @param {Array} funds - Filtered funds to display
         */
        function renderTimelineTable(funds) {
            const container = document.getElementById('timelineTableContainer');
            const panel = document.getElementById('timelinePanel');

            // Lazy rendering: skip if panel is collapsed (will render when expanded)
            if (CONFIG.LAZY_RENDER_TIMELINE && panel && !panel.classList.contains('expanded')) {
                // Clear existing content to trigger re-render when expanded
                container.innerHTML = '';
                return;
            }

            if (!funds || funds.length === 0) {
                container.innerHTML = '<p class="timeline-no-data">No investments to display. <a href="#" onclick="showAddFundModal(); return false;" style="color: var(--color-action);">Add your first investment</a> with cash flows to see the timeline.</p>';
                return;
            }

            // Get the cutoff date from the filter
            const cutoffDateValue = document.getElementById('cutoffDate').value;
            const cutoffDate = cutoffDateValue ? new Date(cutoffDateValue) : null;
            const cutoffYear = cutoffDate ? cutoffDate.getFullYear() : null;

            // Aggregate data using cutoff date
            const historical = aggregateHistoricalCashFlows(funds, cutoffDate);
            const projected = calculateProjectedCalls(funds, fundNameData, cutoffDate);
            const yearRange = getTimelineYearRange(historical, projected, cutoffYear);

            if (yearRange.years.length === 0) {
                container.innerHTML = '<p class="timeline-no-data">No cash flow data available for the selected funds.</p>';
                return;
            }

            // Build table HTML
            let html = '<table class="timeline-table">';

            // Header row
            html += '<thead><tr><th></th>';
            yearRange.years.forEach(year => {
                const isProjected = yearRange.firstProjectedYear && year >= yearRange.firstProjectedYear;
                const isDivider = year === yearRange.firstProjectedYear;
                html += `<th class="${isProjected ? 'year-projected' : ''} ${isDivider ? 'timeline-divider' : ''}">${year}${isProjected ? '*' : ''}</th>`;
            });
            html += '</tr></thead>';

            // Body
            html += '<tbody>';

            // Get unique fund names for expandable rows
            const fundNames = [...new Set(funds.map(f => f.fundName))].sort();

            // Capital Calls row (expandable)
            html += buildTimelineRow('Capital Calls', 'calls', yearRange, historical.calls, projected.projectedCalls, true, fundNames, historical.byFund, projected.byFund, 'calls');

            // Distributions row (expandable)
            html += buildTimelineRow('Distributions', 'distributions', yearRange, historical.distributions, {}, true, fundNames, historical.byFund, {}, 'distributions');

            // Net Cash Flow row
            html += buildNetCashFlowRow(yearRange, historical, projected);

            html += '</tbody></table>';

            // Add footnote for projected
            if (yearRange.firstProjectedYear) {
                const footnoteText = cutoffDate
                    ? `* Projected values (after ${cutoffDateValue}) based on remaining uncalled capital distributed linearly across investment period`
                    : '* Projected values based on remaining uncalled capital distributed linearly across investment period';
                html += `<p style="margin-top: 10px; font-size: 11px; color: var(--color-text-light); font-style: italic;">${footnoteText}</p>`;
            }

            container.innerHTML = html;

            // Add click handlers for expandable rows
            container.querySelectorAll('.timeline-expand-row').forEach(row => {
                row.addEventListener('click', function() {
                    const type = this.dataset.type;
                    const isExpanded = this.classList.toggle('expanded');
                    const icon = this.querySelector('.timeline-expand-icon');
                    icon.textContent = isExpanded ? '▼' : '▶';

                    // Toggle fund detail rows
                    container.querySelectorAll(`.timeline-fund-row[data-type="${type}"]`).forEach(fundRow => {
                        fundRow.classList.toggle('visible', isExpanded);
                    });
                });
            });
        }

        /**
         * Build a timeline row with expandable fund breakdown
         */
        function buildTimelineRow(label, type, yearRange, historicalData, projectedData, expandable, fundNames, historicalByFund, projectedByFund, dataType) {
            let html = '';

            // Main row - escape label and type for XSS protection
            const safeLabel = escapeHtml(label);
            const safeType = escapeHtml(type);
            const rowClass = type === 'calls' ? 'row-calls' : 'row-distributions';
            html += `<tr class="${rowClass} ${expandable ? 'timeline-expand-row' : ''}" ${expandable ? `data-type="${safeType}"` : ''}>`;
            html += `<td class="row-label">${expandable ? '<span class="timeline-expand-icon">▶</span>' : ''}${safeLabel}</td>`;

            yearRange.years.forEach(year => {
                const isProjected = yearRange.firstProjectedYear && year >= yearRange.firstProjectedYear;
                const isDivider = year === yearRange.firstProjectedYear;

                let value = 0;
                if (isProjected && projectedData[year]) {
                    value = projectedData[year];
                } else if (!isProjected && historicalData[year]) {
                    value = historicalData[year];
                }

                const cellClass = `${isProjected ? 'year-projected' : ''} ${isDivider ? 'timeline-divider' : ''}`;
                html += `<td class="${cellClass}">${value > 0 ? formatCurrency(value) : '-'}</td>`;
            });

            html += '</tr>';

            // Fund breakdown rows (hidden by default)
            if (expandable && fundNames) {
                fundNames.forEach(fundName => {
                    html += `<tr class="timeline-fund-row" data-type="${safeType}">`;
                    html += `<td>${escapeHtml(fundName)}</td>`;

                    yearRange.years.forEach(year => {
                        const isProjected = yearRange.firstProjectedYear && year >= yearRange.firstProjectedYear;
                        const isDivider = year === yearRange.firstProjectedYear;

                        let value = 0;
                        if (isProjected && projectedByFund[fundName] && projectedByFund[fundName][year]) {
                            value = projectedByFund[fundName][year];
                        } else if (!isProjected && historicalByFund[fundName] && historicalByFund[fundName][dataType] && historicalByFund[fundName][dataType][year]) {
                            value = historicalByFund[fundName][dataType][year];
                        }

                        const cellClass = `${isProjected ? 'year-projected' : ''} ${isDivider ? 'timeline-divider' : ''}`;
                        html += `<td class="${cellClass}">${value > 0 ? formatCurrency(value) : '-'}</td>`;
                    });

                    html += '</tr>';
                });
            }

            return html;
        }

        /**
         * Build the net cash flow row
         */
        function buildNetCashFlowRow(yearRange, historical, projected) {
            let html = '<tr class="row-net">';
            html += '<td class="row-label">Net Cash Flow</td>';

            yearRange.years.forEach(year => {
                const isProjected = yearRange.firstProjectedYear && year >= yearRange.firstProjectedYear;
                const isDivider = year === yearRange.firstProjectedYear;

                let calls = 0;
                let distributions = 0;

                if (isProjected) {
                    calls = projected.projectedCalls[year] || 0;
                    // No projected distributions
                } else {
                    calls = historical.calls[year] || 0;
                    distributions = historical.distributions[year] || 0;
                }

                const net = distributions - calls;
                const cellClass = `${isProjected ? 'year-projected' : ''} ${isDivider ? 'timeline-divider' : ''} ${net >= 0 ? 'positive' : 'negative'}`;

                let displayValue = '-';
                if (calls > 0 || distributions > 0) {
                    displayValue = (net >= 0 ? '+' : '') + formatCurrency(net);
                }

                html += `<td class="${cellClass}">${displayValue}</td>`;
            });

            html += '</tr>';
            return html;
        }

        /**
         * Toggle timeline panel expand/collapse with lazy rendering
         */
        function toggleTimelinePanel() {
            const panel = document.getElementById('timelinePanel');
            const wasExpanded = panel.classList.contains('expanded');
            panel.classList.toggle('expanded');

            // Lazy render: only render when expanding and not yet rendered
            if (!wasExpanded && CONFIG.LAZY_RENDER_TIMELINE) {
                const container = document.getElementById('timelineTableContainer');
                // Check if we need to render (empty or placeholder content)
                if (!container.querySelector('.timeline-table')) {
                    renderTimelineTable(applyCurrentFilters(currentFunds));
                }
            }

            // Save preference
            Storage.set('timelinePanelExpanded', panel.classList.contains('expanded'));
        }

        function toggleDarkMode() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const newTheme = isDark ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            Storage.set('darkMode', newTheme === 'dark');
            document.getElementById('sidebarDarkModeCheckbox').checked = newTheme === 'dark';
        }

        /**
         * Initialize dark mode from saved preference
         */
        function initializeDarkMode() {
            const savedDarkMode = Storage.get('darkMode', false);
            if (savedDarkMode) {
                document.documentElement.setAttribute('data-theme', 'dark');
                document.getElementById('sidebarDarkModeCheckbox').checked = true;
            }
        }

        /**
         * Show keyboard shortcuts modal
         */
        function showShortcutsModal() {
            document.getElementById('shortcutsModal').classList.add('show');
        }

        /**
         * Close keyboard shortcuts modal
         */
        function closeShortcutsModal() {
            document.getElementById('shortcutsModal').classList.remove('show');
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            sidebar.classList.add('show');
            overlay.classList.add('show');
            document.body.classList.add('sidebar-open');
        }

        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            sidebar.classList.remove('show');
            overlay.classList.remove('show');
            document.body.classList.remove('sidebar-open');
        }

        async function toggleTagsDisplay() {
            const checkbox = document.getElementById('sidebarShowTagsCheckbox');
            // Save preference to localStorage
            Storage.set('showTags', checkbox.checked);
            // Re-render table to show/hide tags
            await renderTable();
            // Also refresh Manage Funds list if it's open
            const manageFundsModal = document.getElementById('manageFundNamesModal');
            if (manageFundsModal && manageFundsModal.classList.contains('show')) {
                await loadFundNamesList();
            }
        }

        function sortData(data, sortSpecs) {
            if (!sortSpecs || sortSpecs.length === 0) return data;

            // Pre-compute metrics ONCE for all items (performance optimization)
            const cutoffDateValue = document.getElementById('cutoffDate').value;
            const cutoffDate = cutoffDateValue ? new Date(cutoffDateValue) : null;

            // Create a map of fund id -> metrics to avoid recalculating during sort
            const metricsMap = new Map();
            data.forEach(fund => {
                metricsMap.set(fund.id, calculateMetrics(fund, cutoffDate));
            });

            return [...data].sort((a, b) => {
                const metricsA = metricsMap.get(a.id);
                const metricsB = metricsMap.get(b.id);

                for (const { column, direction } of sortSpecs) {
                    let valA, valB;

                    switch(column) {
                        case 'fundName':
                            valA = a[column];
                            valB = b[column];
                            break;
                        case 'accountNumber':
                            // Sort by displayed text (parent name + account number)
                            valA = getParentAccountDisplay(a);
                            valB = getParentAccountDisplay(b);
                            break;
                        case 'vintage':
                        case 'commitment':
                        case 'totalContributions':
                        case 'totalDistributions':
                        case 'nav':
                        case 'investmentReturn':
                        case 'outstandingCommitment':
                        case 'irr':
                        case 'moic':
                            valA = metricsA[column] ?? -Infinity;
                            valB = metricsB[column] ?? -Infinity;
                            break;
                        default:
                            continue;
                    }

                    if (valA < valB) return direction === 'asc' ? -1 : 1;
                    if (valA > valB) return direction === 'asc' ? 1 : -1;
                    // If equal, continue to next sort column
                }
                return 0;
            });
        }

        async function sortTable(column) {
            const existingIndex = sortColumns.findIndex(s => s.column === column);

            if (existingIndex === -1) {
                // Column not in sort list - add as ascending
                AppState.setSortColumns([...sortColumns, { column, direction: 'asc' }]);
            } else if (sortColumns[existingIndex].direction === 'asc') {
                // Currently ascending - change to descending
                const newColumns = [...sortColumns];
                newColumns[existingIndex] = { ...newColumns[existingIndex], direction: 'desc' };
                AppState.setSortColumns(newColumns);
            } else {
                // Currently descending - remove from sort list
                AppState.setSortColumns(sortColumns.filter((_, i) => i !== existingIndex));
            }

            // Update header classes
            updateSortHeaders();
            await renderTable();
        }

        function updateSortHeaders() {
            const headers = document.querySelectorAll('#fundsTable th');
            const columnNames = ['fundName', 'accountNumber', 'vintage', 'commitment', 'totalContributions', 'totalDistributions', 'nav', 'investmentReturn', 'moic', 'irr', 'outstandingCommitment'];

            headers.forEach((th, index) => {
                th.classList.remove('sorted-asc', 'sorted-desc');
                th.removeAttribute('data-sort-priority');

                const columnName = columnNames[index];
                const sortIndex = sortColumns.findIndex(s => s.column === columnName);

                if (sortIndex !== -1) {
                    th.classList.add(`sorted-${sortColumns[sortIndex].direction}`);
                    if (sortColumns.length > 1) {
                        th.setAttribute('data-sort-priority', sortIndex + 1);
                    }
                }
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ===========================
        // JSON Example Functions
        // ===========================

        function fillCashFlowsExample() {
            const textarea = document.getElementById('cashFlows');
            const currentYear = new Date().getFullYear();
            const example = [
                { date: `${currentYear}-01-15`, amount: -500000, type: "Contribution", affectsCommitment: true },
                { date: `${currentYear}-04-15`, amount: -300000, type: "Contribution", affectsCommitment: true },
                { date: `${currentYear}-07-20`, amount: 150000, type: "Distribution", affectsCommitment: false }
            ];
            textarea.value = JSON.stringify(example, null, 2);
            textarea.focus();
            showStatus('Example cash flows added. Modify the dates and amounts as needed.', 'success');
        }

        function fillNavExample() {
            const textarea = document.getElementById('monthlyNav');
            const currentYear = new Date().getFullYear();
            const example = [
                { date: `${currentYear}-01-31`, amount: 480000 },
                { date: `${currentYear}-02-28`, amount: 495000 },
                { date: `${currentYear}-03-31`, amount: 510000 }
            ];
            textarea.value = JSON.stringify(example, null, 2);
            textarea.focus();
            showStatus('Example NAV entries added. Modify the dates and amounts as needed.', 'success');
        }

        // ===========================
        // Modal Functions
        // ===========================

        async function showAddFundModal() {
            try {
                document.getElementById('fundModalTitle').textContent = 'Add New Investment';
                document.getElementById('fundId').value = '';
                document.getElementById('isDuplicate').value = '';
                document.getElementById('duplicateMultiplierContainer').style.display = 'none';

                // Reset inline fund name input state
                document.getElementById('newFundNameContainer').style.display = 'none';
                document.getElementById('fundName').style.display = '';
                clearFieldErrors();

                await populateFundNamesDropdown();
                await populateFundGroupDropdown();

                // Reset other form fields (not the fund name dropdown which we just populated)
                document.getElementById('accountNumber').value = '';
                document.getElementById('commitment').value = '';
                document.getElementById('cashFlows').value = '';
                document.getElementById('monthlyNav').value = '';

                document.getElementById('fundModal').classList.add('show');
            } catch (err) {
                showStatus('Error opening add investment modal: ' + err.message, 'error');
                Debug.error('Error in showAddFundModal:', err);
            }
        }

        async function editFund(id) {
            try {
                const fund = await getFundById(id);
                if (!fund) {
                    showStatus('Fund not found', 'error');
                    return;
                }

                Debug.log('Editing fund:', fund);
                Debug.log('Fund monthlyNav:', fund.monthlyNav);

                document.getElementById('fundModalTitle').textContent = 'Edit Investment';
                document.getElementById('fundId').value = fund.id;
                document.getElementById('isDuplicate').value = '';
                document.getElementById('duplicateMultiplierContainer').style.display = 'none';

                await populateFundNamesDropdown(fund.fundName);
                await populateFundGroupDropdown(fund.groupId);
                document.getElementById('accountNumber').value = fund.accountNumber;
                document.getElementById('commitment').value = formatCurrency(parseCurrency(fund.commitment) || 0);
                document.getElementById('cashFlows').value = JSON.stringify(fund.cashFlows || [], null, 2);
                document.getElementById('monthlyNav').value = JSON.stringify(fund.monthlyNav || [], null, 2);

                Modal.show('fundModal');
            } catch (err) {
                showStatus('Error loading fund: ' + err.message, 'error');
                Debug.error('Error in editFund:', err);
            }
        }

        async function duplicateFund(id) {
            try {
                const fund = await getFundById(id);
                if (!fund) {
                    showStatus('Fund not found', 'error');
                    return;
                }

                document.getElementById('fundModalTitle').textContent = 'Duplicate Investment';
                document.getElementById('fundId').value = '';
                document.getElementById('isDuplicate').value = id;
                document.getElementById('duplicateMultiplierContainer').style.display = 'block';
                document.getElementById('duplicateMultiplier').value = '1';

                await populateFundNamesDropdown(fund.fundName);
                await populateFundGroupDropdown(fund.groupId);
                document.getElementById('accountNumber').value = fund.accountNumber + ' (Copy)';
                document.getElementById('commitment').value = formatCurrency(parseCurrency(fund.commitment) || 0);
                document.getElementById('cashFlows').value = JSON.stringify(fund.cashFlows || [], null, 2);
                document.getElementById('monthlyNav').value = JSON.stringify(fund.monthlyNav || [], null, 2);

                document.getElementById('fundModal').classList.add('show');
            } catch (err) {
                showStatus('Error loading fund: ' + err.message, 'error');
            }
        }

        function closeFundModal() {
            document.getElementById('fundModal').classList.remove('show');
        }

        // Tag management functions
        // Handle tag input for Edit Fund Name modal
        document.addEventListener('keydown', function(event) {
            if (event.target.id === 'editFundTagsInput' && event.key === 'Enter') {
                event.preventDefault();
                const input = event.target;
                const tagName = input.value.trim();
                if (tagName) {
                    const currentTags = getEditFundTags();
                    if (!currentTags.includes(tagName)) {
                        addEditFundTag(tagName);
                        input.value = '';
                    } else {
                        showStatus('Tag already added', 'warning');
                    }
                }
            }
        });

        // Form validation UX helpers
        function highlightFieldError(fieldId) {
            const field = document.getElementById(fieldId);
            if (field) {
                const formGroup = field.closest('.form-group');
                if (formGroup) {
                    formGroup.classList.add('has-error');
                }
                field.focus();
                field.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function clearFieldErrors() {
            document.querySelectorAll('.form-group.has-error').forEach(group => {
                group.classList.remove('has-error');
            });
        }

        async function saveFund(event) {
            event.preventDefault();
            clearFieldErrors();

            try {
                const fundId = document.getElementById('fundId').value;
                const isDuplicate = document.getElementById('isDuplicate').value;
                let fundName = document.getElementById('fundName').value.trim();

                // Handle inline fund name creation - if dropdown is "__new__", use the inline input
                if (fundName === '__new__') {
                    const inlineInput = document.getElementById('newFundNameInline');
                    const inlineName = inlineInput.value.trim();

                    if (!inlineName) {
                        highlightFieldError('fundName');
                        showStatus('Please enter a fund name or click Cancel to select an existing one', 'error');
                        inlineInput.focus();
                        return;
                    }

                    // Validate the inline fund name
                    if (inlineName.length < 2) {
                        highlightFieldError('fundName');
                        showStatus('Fund name too short (min 2 characters)', 'error');
                        inlineInput.focus();
                        return;
                    }

                    if (inlineName.length > 100) {
                        highlightFieldError('fundName');
                        showStatus('Fund name too long (max 100 characters)', 'error');
                        inlineInput.focus();
                        return;
                    }

                    // Save the new fund name if it doesn't exist
                    if (!fundNames.has(inlineName)) {
                        await saveFundName(inlineName);
                        fundNames.add(inlineName);
                        fundNameData.set(inlineName, { name: inlineName, tags: [] });
                    }

                    fundName = inlineName;
                }

                const accountNumber = document.getElementById('accountNumber').value.trim();
                const groupId = document.getElementById('fundGroup').value;
                const commitmentText = document.getElementById('commitment').value.trim();
                const cashFlowsText = document.getElementById('cashFlows').value.trim();
                const monthlyNavText = document.getElementById('monthlyNav').value.trim();

                // Validate fund name
                const fundNameValidation = validateFundName(fundName);
                if (!fundNameValidation.valid) {
                    highlightFieldError('fundName');
                    showStatus(fundNameValidation.error, 'error');
                    return;
                }

                // Validate account number
                const accountValidation = validateAccountNumber(accountNumber);
                if (!accountValidation.valid) {
                    highlightFieldError('accountNumber');
                    showStatus(accountValidation.error, 'error');
                    return;
                }

                // Validate commitment is present
                if (!commitmentText) {
                    highlightFieldError('commitment');
                    showStatus('Please enter a commitment amount', 'error');
                    return;
                }

                // Parse commitment
                let commitment = parseCurrency(commitmentText);
                if (isNaN(commitment)) {
                    highlightFieldError('commitment');
                    showStatus('Invalid commitment amount', 'error');
                    return;
                }
                if (commitment < 0) {
                    highlightFieldError('commitment');
                    showStatus('Commitment amount cannot be negative', 'error');
                    return;
                }

                // Parse and validate JSON
                let cashFlows, monthlyNav;

                // Parse cash flows (optional)
                if (cashFlowsText) {
                    try {
                        cashFlows = JSON.parse(cashFlowsText);
                        if (!Array.isArray(cashFlows)) throw new Error('Cash flows must be an array');
                    } catch (err) {
                        highlightFieldError('cashFlows');
                        showStatus('Invalid cash flows JSON: ' + err.message, 'error');
                        return;
                    }

                    // Validate cash flows using validation function
                    const cashFlowValidation = validateCashFlows(cashFlows);
                    if (!cashFlowValidation.valid) {
                        highlightFieldError('cashFlows');
                        const errorMsg = cashFlowValidation.index !== null
                            ? `Cash flow #${cashFlowValidation.index + 1}: ${cashFlowValidation.error}`
                            : cashFlowValidation.error;
                        showStatus(errorMsg, 'error');
                        return;
                    }
                } else {
                    cashFlows = [];
                }

                // Parse monthly NAV
                try {
                    monthlyNav = monthlyNavText ? JSON.parse(monthlyNavText) : [];
                    if (!Array.isArray(monthlyNav)) throw new Error('Monthly NAV must be an array');
                } catch (err) {
                    highlightFieldError('monthlyNav');
                    showStatus('Invalid monthly NAV JSON: ' + err.message, 'error');
                    return;
                }

                // Validate monthly NAV using validation function
                const navValidation = validateMonthlyNav(monthlyNav);
                if (!navValidation.valid) {
                    highlightFieldError('monthlyNav');
                    const errorMsg = navValidation.index !== null
                        ? `NAV entry #${navValidation.index + 1}: ${navValidation.error}`
                        : navValidation.error;
                    showStatus(errorMsg, 'error');
                    return;
                }

                // Check for duplicate fund (same fund name + account number)
                const existingFunds = currentFunds.filter(f =>
                    f.fundName === fundName &&
                    f.accountNumber === accountNumber &&
                    (!fundId || f.id !== parseInt(fundId)) // Exclude current fund if editing
                );

                if (existingFunds.length > 0) {
                    const proceed = confirm(
                        `A fund with the same name "${fundName}" and account number "${accountNumber}" already exists.\n\n` +
                        `Are you sure you want to create another one?`
                    );
                    if (!proceed) {
                        highlightFieldError('accountNumber');
                        return;
                    }
                }

                // Handle duplicate multiplier
                if (isDuplicate) {
                    const multiplier = parseFloat(document.getElementById('duplicateMultiplier').value) || 1;

                    if (multiplier <= 0) {
                        showStatus('Duplicate multiplier must be positive', 'error');
                        return;
                    }

                    if (multiplier > 1000) {
                        if (!confirm(`Warning: Multiplier of ${multiplier} is very large. This will create extremely large amounts. Continue?`)) {
                            return;
                        }
                    }

                    if (multiplier < 0.001) {
                        if (!confirm(`Warning: Multiplier of ${multiplier} is very small. This may result in rounding to zero. Continue?`)) {
                            return;
                        }
                    }

                    commitment = commitment * multiplier;

                    cashFlows = cashFlows.map(cf => ({
                        ...cf,
                        amount: parseCurrency(cf.amount) * multiplier
                    }));

                    monthlyNav = monthlyNav.map(nav => ({
                        ...nav,
                        amount: parseCurrency(nav.amount) * multiplier
                    }));
                }

                const fundData = {
                    fundName,
                    accountNumber,
                    groupId: groupId ? parseInt(groupId) : null,
                    commitment: commitment,
                    cashFlows,
                    monthlyNav,
                    timestamp: new Date().toISOString()
                };

                // Show loading state
                const saveBtn = document.getElementById('saveFundBtn');
                const originalBtnText = saveBtn.textContent;
                saveBtn.textContent = 'Saving...';
                saveBtn.disabled = true;

                if (fundId) {
                    fundData.id = parseInt(fundId);
                }

                await saveFundToDB(fundData);

                // Save fund name if new
                if (!fundNames.has(fundName)) {
                    await saveFundName(fundName);
                    fundNames.add(fundName);
                    fundNameData.set(fundName, { name: fundName, tags: [] });
                }

                // Clear metrics cache since data changed
                AppState.clearMetricsCache();

                // Reset button state before closing modal
                saveBtn.textContent = 'Save';
                saveBtn.disabled = false;

                closeFundModal();
                await renderTable();
                showStatus(fundId ? 'Fund updated successfully' : 'Fund added successfully');

                // Update last backup reminder
                checkBackupReminder();

            } catch (err) {
                // Reset loading state on error
                const saveBtn = document.getElementById('saveFundBtn');
                if (saveBtn) {
                    saveBtn.textContent = 'Save';
                    saveBtn.disabled = false;
                }
                showStatus('Error saving fund: ' + err.message, 'error');
                Debug.error('Error saving fund:', err);
            }
        }

        async function showActionModal(id, buttonElement) {
            Debug.log('showActionModal called with ID:', id, 'Type:', typeof id);

            if (!id && id !== 0) {
                Debug.error('Invalid fund ID provided to showActionModal:', id);
                showStatus('Error: Invalid fund ID provided', 'error');
                return;
            }

            currentActionFundId = id;

            try {
                const fund = await getFundById(id);
                if (!fund) {
                    showStatus('Fund not found', 'error');
                    return;
                }

                Debug.log('Action dropdown showing for fund:', fund.fundName, 'ID:', fund.id);

                // Position and show the dropdown
                const dropdown = document.getElementById('actionDropdown');
                const rect = buttonElement.getBoundingClientRect();

                // Get dropdown dimensions (temporarily show to measure)
                dropdown.style.visibility = 'hidden';
                dropdown.classList.add('show');
                const dropdownWidth = dropdown.offsetWidth || 160;
                const dropdownHeight = dropdown.offsetHeight || 200;
                dropdown.classList.remove('show');
                dropdown.style.visibility = '';

                // Calculate position with viewport boundary checks
                let top = rect.bottom + 2;
                let left = rect.left - (dropdownWidth - rect.width);

                // Check if dropdown would go below viewport
                if (top + dropdownHeight > window.innerHeight) {
                    // Position above the button instead
                    top = rect.top - dropdownHeight - 2;
                }

                // Check if dropdown would go past left edge
                if (left < 8) {
                    left = 8;
                }

                // Check if dropdown would go past right edge
                if (left + dropdownWidth > window.innerWidth - 8) {
                    left = window.innerWidth - dropdownWidth - 8;
                }

                // Ensure top is not negative
                if (top < 8) {
                    top = 8;
                }

                dropdown.style.top = `${top}px`;
                dropdown.style.left = `${left}px`;

                dropdown.classList.add('show');
            } catch (err) {
                Debug.error('Error in showActionModal:', err);
                showStatus('Error loading fund: ' + err.message, 'error');
            }
        }

        function closeActionModal() {
            const dropdown = document.getElementById('actionDropdown');
            dropdown.classList.remove('show');
            currentActionFundId = null;
        }

        function editFundFromAction() {
            const fundId = currentActionFundId;
            if (fundId == null) {
                showStatus('Error: No fund selected', 'error');
                return;
            }
            closeActionModal();
            editFund(fundId);
        }

        function duplicateFundFromAction() {
            const fundId = currentActionFundId;
            if (fundId == null) {
                showStatus('Error: No fund selected', 'error');
                return;
            }
            closeActionModal();
            duplicateFund(fundId);
        }

        async function deleteFundFromAction() {
            if (currentActionFundId == null) return;

            try {
                const fund = await getFundById(currentActionFundId);
                if (!fund) {
                    showStatus('Fund not found', 'error');
                    return;
                }

                if (confirm(`Are you sure you want to delete "${fund.fundName} - ${fund.accountNumber}"?`)) {
                    await deleteFundFromDB(currentActionFundId);

                    // Clear metrics cache
                    AppState.clearMetricsCache();

                    closeActionModal();
                    await renderTable();
                    showStatus('Fund deleted successfully', 'success');
                }
            } catch (err) {
                showStatus('Error deleting fund: ' + err.message, 'error');
            }
        }

        function showDetailsFromAction() {
            // Capture the ID before closing the modal
            const fundId = currentActionFundId;
            Debug.log('Opening details for fund ID:', fundId);
            if (fundId == null) {
                Debug.error('No fund ID available');
                showStatus('Error: No fund selected', 'error');
                return;
            }
            closeActionModal();
            showDetailsModal(fundId);
        }

        async function showDetailsModal(id) {
            Debug.log('showDetailsModal called with ID:', id, 'Type:', typeof id);

            if (!id && id !== 0) {
                Debug.error('Invalid fund ID provided to showDetailsModal:', id);
                showStatus('Error: Invalid fund ID provided', 'error');
                return;
            }

            currentDetailsFundId = id;

            try {
                Debug.log('Loading fund details for ID:', id);
                const fund = await getFundById(id);

                if (!fund) {
                    Debug.error('Fund not found:', id);
                    showStatus('Fund not found', 'error');
                    return;
                }

                Debug.log('Fund loaded:', fund);

                document.getElementById('detailsModalTitle').textContent =
                    `Fund Details - ${fund.fundName}`;

                // Display last modified timestamp
                const subtitle = document.getElementById('detailsModalSubtitle');
                if (fund.timestamp) {
                    try {
                        const date = new Date(fund.timestamp);
                        const formatted = date.toLocaleString('en-US', {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        subtitle.textContent = `Last modified: ${formatted}`;
                    } catch (err) {
                        subtitle.textContent = '';
                    }
                } else {
                    subtitle.textContent = '';
                }

                // Populate cash flows table using Templates
                const cashFlowsTable = document.getElementById('cashFlowsTable');
                if (!cashFlowsTable) {
                    Debug.error('Cash flows table not found');
                    showStatus('Error: Cash flows table element not found in page', 'error');
                    return;
                }
                const cashFlowsTableBody = cashFlowsTable.querySelector('tbody');
                if (!cashFlowsTableBody) {
                    Debug.error('Cash flows table body not found');
                    showStatus('Error: Cash flows table body element not found in page', 'error');
                    return;
                }

                // Build all cash flow rows using Templates
                Debug.log('Cash flows:', fund.cashFlows);
                const cashFlowsHtml = (fund.cashFlows || [])
                    .map((cf, index) => Templates.cashFlowRow(cf, index))
                    .join('');
                cashFlowsTableBody.innerHTML = cashFlowsHtml;

                // Populate NAV table using Templates
                const navTable = document.getElementById('navTable');
                if (!navTable) {
                    Debug.error('NAV table not found');
                    showStatus('Error: NAV table element not found in page', 'error');
                    return;
                }
                const navTableBody = navTable.querySelector('tbody');
                if (!navTableBody) {
                    Debug.error('NAV table body not found');
                    showStatus('Error: NAV table body element not found in page', 'error');
                    return;
                }

                // Build all NAV rows using Templates
                Debug.log('Monthly NAV:', fund.monthlyNav);
                const navHtml = (fund.monthlyNav || [])
                    .map((nav, index) => Templates.navRow(nav, index))
                    .join('');
                navTableBody.innerHTML = navHtml;

                Modal.show('detailsModal');
                AppState.setUnsavedChanges(false);
                Debug.log('Details modal opened successfully');
            } catch (err) {
                Debug.error('Error in showDetailsModal:', err);
                showStatus('Error loading fund details: ' + err.message, 'error');
            }
        }

        function closeDetailsModal() {
            const closed = Modal.close('detailsModal', {
                checkUnsaved: true,
                onClose: () => {
                    currentDetailsFundId = null;
                    AppState.setUnsavedChanges(false);
                }
            });
            // Modal.close returns false if user canceled due to unsaved changes
            return closed;
        }

        function addCashFlowRow() {
            const table = document.getElementById('cashFlowsTable').querySelector('tbody');
            const index = table.children.length;
            // Use Templates for consistent row creation
            table.insertAdjacentHTML('beforeend', Templates.cashFlowRow({}, index));
            AppState.setUnsavedChanges(true);
        }

        function deleteCashFlowRow(button) {
            const row = button.closest('tr');
            if (row) {
                const date = row.querySelector('[data-field="date"]').value;
                const amount = row.querySelector('[data-field="amount"]').value;
                const type = row.querySelector('[data-field="type"]').value;

                const dateText = date || 'no date';
                const amountText = amount || '$0';
                const typeText = type || 'contribution';

                if (confirm(`Delete this cash flow?\n${typeText} on ${dateText}: ${amountText}`)) {
                    row.remove();
                    AppState.setUnsavedChanges(true);
                }
            }
        }

        function addNavRow() {
            const table = document.getElementById('navTable').querySelector('tbody');
            const index = table.children.length;
            // Use Templates for consistent row creation
            table.insertAdjacentHTML('beforeend', Templates.navRow({}, index));
            AppState.setUnsavedChanges(true);
        }

        function deleteNavRow(button) {
            const row = button.closest('tr');
            if (row) {
                const date = row.querySelector('[data-field="date"]').value;
                const amount = row.querySelector('[data-field="amount"]').value;

                const dateText = date || 'no date';
                const amountText = amount || '$0';

                if (confirm(`Delete this NAV entry?\n${dateText}: ${amountText}`)) {
                    row.remove();
                    AppState.setUnsavedChanges(true);
                }
            }
        }

        async function saveDetailsChanges() {
            if (!currentDetailsFundId) return;

            try {
                const fund = await getFundById(currentDetailsFundId);
                if (!fund) {
                    showStatus('Fund not found', 'error');
                    return;
                }

                // Store original counts for comparison
                const originalCashFlowCount = (fund.cashFlows || []).length;
                const originalNavCount = (fund.monthlyNav || []).length;

                // Read cash flows from table
                const cashFlowsTable = document.getElementById('cashFlowsTable').querySelector('tbody');
                const cashFlows = [];
                const invalidCashFlows = [];

                // Clear previous error highlights
                Array.from(cashFlowsTable.children).forEach(row => {
                    row.classList.remove('validation-error-row');
                });

                Array.from(cashFlowsTable.children).forEach((row, index) => {
                    const date = row.querySelector('[data-field="date"]').value;
                    const amount = row.querySelector('[data-field="amount"]').value;
                    const type = row.querySelector('[data-field="type"]').value;
                    const affectsCommitment = row.querySelector('[data-field="affectsCommitment"]').checked;

                    if (date && amount) {
                        // Validate date format (YYYY-MM-DD)
                        if (!isValidDate(date)) {
                            invalidCashFlows.push(index + 1);
                            row.classList.add('validation-error-row');
                        } else {
                            cashFlows.push({
                                date,
                                amount: parseCurrency(amount),
                                type,
                                affectsCommitment
                            });
                        }
                    }
                });

                if (invalidCashFlows.length > 0) {
                    showStatus(`Invalid date format in cash flow row(s): ${invalidCashFlows.join(', ')}. Use YYYY-MM-DD format.`, 'error');
                    return;
                }

                // Read NAV from table
                const navTable = document.getElementById('navTable').querySelector('tbody');
                const monthlyNav = [];
                const invalidNav = [];

                // Clear previous error highlights
                Array.from(navTable.children).forEach(row => {
                    row.classList.remove('validation-error-row');
                });

                Array.from(navTable.children).forEach((row, index) => {
                    const date = row.querySelector('[data-field="date"]').value;
                    const amount = row.querySelector('[data-field="amount"]').value;

                    if (date && amount) {
                        // Validate date format (YYYY-MM-DD)
                        if (!isValidDate(date)) {
                            invalidNav.push(index + 1);
                            row.classList.add('validation-error-row');
                        } else {
                            monthlyNav.push({
                                date,
                                amount: parseCurrency(amount)
                            });
                        }
                    }
                });

                if (invalidNav.length > 0) {
                    showStatus(`Invalid date format in NAV row(s): ${invalidNav.join(', ')}. Use YYYY-MM-DD format.`, 'error');
                    return;
                }

                // Warn if significant data is being deleted
                if (originalCashFlowCount > 0 && cashFlows.length < originalCashFlowCount / 2) {
                    if (!confirm(`Warning: You are deleting ${originalCashFlowCount - cashFlows.length} cash flow(s). Continue?`)) {
                        return;
                    }
                }

                if (originalNavCount > 0 && monthlyNav.length < originalNavCount / 2) {
                    if (!confirm(`Warning: You are deleting ${originalNavCount - monthlyNav.length} NAV entr(ies). Continue?`)) {
                        return;
                    }
                }

                // Update fund
                fund.cashFlows = cashFlows;
                fund.monthlyNav = monthlyNav;
                fund.timestamp = new Date().toISOString();

                await saveFundToDB(fund);
                AppState.setUnsavedChanges(false); // Mark as saved before closing
                closeDetailsModal();
                await renderTable();
                showStatus('Details updated successfully');

            } catch (err) {
                showStatus('Error saving details: ' + err.message, 'error');
                Debug.error('Error saving details:', err);
            }
        }

        async function showManageFundsModal() {
            try {
                await loadFundNamesList();
                await populateFundNamesDropdown();
                document.getElementById('manageFundNamesModal').classList.add('show');
            } catch (err) {
                showStatus('Error opening manage funds modal: ' + err.message, 'error');
                Debug.error('Error in showManageFundsModal:', err);
            }
        }

        function closeManageFundsModal() {
            document.getElementById('manageFundNamesModal').classList.remove('show');
        }

        async function loadFundNamesList() {
            try {
                const fundNameObjects = await getAllFundNameObjects();
                AppState.setFundNames(new Set(fundNameObjects.map(obj => obj.name)));
                AppState.setFundNameData(new Map(fundNameObjects.map(obj => [obj.name, obj])));

                const container = document.getElementById('fundNamesList');
                container.innerHTML = '';

                if (fundNameObjects.length === 0) {
                    container.innerHTML = '<p style="color: #95A5A6;">No fund names yet</p>';
                    return;
                }

                fundNameObjects.forEach(fundNameObj => {
                    const div = document.createElement('div');
                    div.className = 'fund-name-item';

                    const nameDiv = document.createElement('div');
                    nameDiv.style.flex = '1';
                    nameDiv.style.minWidth = '0';

                    const nameSpan = document.createElement('div');
                    nameSpan.textContent = fundNameObj.name;
                    nameSpan.style.fontWeight = '500';
                    nameSpan.style.marginBottom = '4px';
                    nameDiv.appendChild(nameSpan);

                    // Show tags if any and if tags are enabled
                    const showTags = document.getElementById('sidebarShowTagsCheckbox').checked;
                    if (showTags && fundNameObj.tags && fundNameObj.tags.length > 0) {
                        const tagsDiv = document.createElement('div');
                        tagsDiv.className = 'table-tags';
                        tagsDiv.style.marginTop = '4px';
                        fundNameObj.tags.forEach(tag => {
                            const tagSpan = document.createElement('span');
                            tagSpan.className = 'table-tag';
                            tagSpan.textContent = tag;
                            tagsDiv.appendChild(tagSpan);
                        });
                        nameDiv.appendChild(tagsDiv);
                    }

                    const editBtn = document.createElement('button');
                    editBtn.className = 'btn-icon';
                    editBtn.textContent = '✎';
                    editBtn.title = 'Edit';
                    editBtn.setAttribute('data-fund-name', fundNameObj.name);
                    editBtn.onclick = function() { openEditFundNameModal(this.getAttribute('data-fund-name')); };

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'btn-icon';
                    deleteBtn.textContent = '×';
                    deleteBtn.title = 'Delete';
                    deleteBtn.style.color = '#E74C3C';
                    deleteBtn.setAttribute('data-fund-name', fundNameObj.name);
                    deleteBtn.onclick = function() { removeFundName(this.getAttribute('data-fund-name')); };

                    div.appendChild(nameDiv);
                    div.appendChild(editBtn);
                    div.appendChild(deleteBtn);
                    container.appendChild(div);
                });
            } catch (err) {
                showStatus('Error loading fund names: ' + err.message, 'error');
            }
        }

        async function addNewFundName() {
            const input = document.getElementById('newFundNameInput');
            const name = input.value.trim();

            if (!name) {
                showStatus('Please enter a fund name', 'error');
                return;
            }

            if (fundNames.has(name)) {
                showStatus('Fund name already exists', 'error');
                return;
            }

            // Get optional fund term fields
            const firstCloseDate = document.getElementById('newFundFirstClose').value || null;
            const finalCloseDate = document.getElementById('newFundFinalClose').value || null;
            const investmentTermYears = document.getElementById('newFundInvestmentTerm').value
                ? parseInt(document.getElementById('newFundInvestmentTerm').value)
                : null;

            try {
                const fundNameObj = {
                    name,
                    tags: [],
                    firstCloseDate,
                    finalCloseDate,
                    investmentTermYears
                };
                await saveFundName(fundNameObj);

                fundNames.add(name);
                fundNameData.set(name, fundNameObj);

                // Reset form fields
                input.value = '';
                document.getElementById('newFundFirstClose').value = '';
                document.getElementById('newFundFinalClose').value = '';
                document.getElementById('newFundInvestmentTerm').value = '';
                document.getElementById('newFundTermsDetails').removeAttribute('open');

                await loadFundNamesList();
                showStatus('Fund name added successfully');
            } catch (err) {
                showStatus('Error adding fund name: ' + err.message, 'error');
            }
        }

        // Open Edit Fund Name Modal
        function openEditFundNameModal(fundName) {
            const fundNameObj = fundNameData.get(fundName);
            if (!fundNameObj) {
                showStatus('Fund name not found', 'error');
                return;
            }

            document.getElementById('editFundNameOriginal').value = fundName;
            document.getElementById('editFundNameInput').value = fundName;

            // Populate tags
            populateEditFundTagsDatalist();
            setEditFundTags(fundNameObj.tags || []);

            // Populate fund terms
            document.getElementById('editFundFirstClose').value = fundNameObj.firstCloseDate || '';
            document.getElementById('editFundFinalClose').value = fundNameObj.finalCloseDate || '';
            document.getElementById('editFundInvestmentTerm').value = fundNameObj.investmentTermYears || '';

            document.getElementById('editFundNameModal').classList.add('show');
        }

        function closeEditFundNameModal() {
            document.getElementById('editFundNameModal').classList.remove('show');
        }

        // Tag management for Edit Fund Name modal
        function addEditFundTag(tagName) {
            const container = document.getElementById('editFundTagsContainer');
            const tag = document.createElement('span');
            tag.className = 'tag';
            tag.innerHTML = `${escapeHtml(tagName)}<span class="tag-remove" data-action="removeTag">×</span>`;
            tag.setAttribute('data-tag', tagName);
            container.appendChild(tag);

            populateEditFundTagsDatalist();
        }

        function removeEditFundTag(button) {
            const tag = button.closest('.tag');
            if (tag) {
                tag.remove();
            }
        }

        function getEditFundTags() {
            const container = document.getElementById('editFundTagsContainer');
            const tagElements = container.querySelectorAll('.tag');
            return Array.from(tagElements).map(tag => tag.getAttribute('data-tag'));
        }

        function setEditFundTags(tagArray) {
            const container = document.getElementById('editFundTagsContainer');
            container.innerHTML = '';
            if (Array.isArray(tagArray)) {
                tagArray.forEach(tagName => addEditFundTag(tagName));
            }
        }

        function populateEditFundTagsDatalist() {
            const datalist = document.getElementById('editFundTagsDatalist');
            datalist.innerHTML = '';

            // Collect all unique tags from all fund names
            const allTags = new Set();
            fundNameData.forEach(fundNameObj => {
                if (fundNameObj.tags) {
                    fundNameObj.tags.forEach(tag => allTags.add(tag));
                }
            });

            allTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                datalist.appendChild(option);
            });
        }

        // Save edited fund name
        async function saveEditedFundName() {
            const oldName = document.getElementById('editFundNameOriginal').value;
            const newName = document.getElementById('editFundNameInput').value.trim();
            const tags = getEditFundTags();

            // Get fund term fields
            const firstCloseDate = document.getElementById('editFundFirstClose').value || null;
            const finalCloseDate = document.getElementById('editFundFinalClose').value || null;
            const investmentTermYears = document.getElementById('editFundInvestmentTerm').value
                ? parseInt(document.getElementById('editFundInvestmentTerm').value)
                : null;

            if (!newName) {
                showStatus('Fund name cannot be empty', 'error');
                return;
            }

            if (fundNames.has(newName) && newName !== oldName) {
                showStatus('Fund name already exists', 'error');
                return;
            }

            try {
                showLoading('Updating fund name...');

                const oldFundNameObj = fundNameData.get(oldName);
                const newFundNameObj = {
                    name: newName,
                    tags,
                    firstCloseDate,
                    finalCloseDate,
                    investmentTermYears
                };

                // If name changed, update all funds that use this name
                if (newName !== oldName) {
                    const funds = await getAllFunds();
                    const fundsToUpdate = funds.filter(f => f.fundName === oldName);

                    const updateErrors = [];
                    for (const fund of fundsToUpdate) {
                        try {
                            fund.fundName = newName;
                            await saveFundToDB(fund);
                        } catch (err) {
                            updateErrors.push(fund.accountNumber);
                            Debug.error(`Failed to update fund ${fund.accountNumber}:`, err);
                        }
                    }

                    if (updateErrors.length > 0) {
                        throw new Error(`Failed to update ${updateErrors.length} fund(s): ${updateErrors.join(', ')}`);
                    }

                    // Delete old name and save new name with tags
                    await deleteFundName(oldName);
                    await saveFundName(newFundNameObj);

                    fundNames.delete(oldName);
                    fundNames.add(newName);
                    fundNameData.delete(oldName);
                    fundNameData.set(newName, newFundNameObj);

                    // Clear metrics cache
                    AppState.clearMetricsCache();

                    await renderTable();
                    showStatus(`Fund name updated successfully (${fundsToUpdate.length} fund(s) updated)`);
                } else {
                    // Just update tags
                    await saveFundName(newFundNameObj);

                    fundNameData.set(newName, newFundNameObj);
                    await renderTable();
                    showStatus('Tags updated successfully');
                }

                closeEditFundNameModal();
                await loadFundNamesList();
            } catch (err) {
                showStatus('Error updating fund name: ' + err.message, 'error');
                Debug.error('Error updating fund name:', err);
            } finally {
                hideLoading();
            }
        }

        async function removeFundName(name) {
            // Check if any investments are using this fund name
            const fundsUsingName = currentFunds.filter(f => f.fundName === name);
            if (fundsUsingName.length > 0) {
                showStatus(`Cannot delete "${name}" - ${fundsUsingName.length} investment(s) are using this fund name`, 'error');
                return;
            }

            if (!confirm(`Are you sure you want to delete "${name}"?`)) {
                return;
            }

            try {
                await deleteFundName(name);
                fundNames.delete(name);
                fundNameData.delete(name);
                await loadFundNamesList();
                showStatus('Fund name deleted successfully', 'success');
            } catch (err) {
                showStatus('Error deleting fund name: ' + err.message, 'error');
            }
        }

        // ===========================
        // Manage Groups Modal Functions
        // ===========================

        async function showManageGroupsModal() {
            try {
                await loadGroupsList();
                await populateGroupParentDropdown();
                document.getElementById('manageGroupsModal').classList.add('show');
            } catch (err) {
                showStatus('Error opening manage groups modal: ' + err.message, 'error');
                Debug.error('Error in showManageGroupsModal:', err);
            }
        }

        function closeManageGroupsModal() {
            document.getElementById('manageGroupsModal').classList.remove('show');
        }

        async function loadGroupsList() {
            try {
                AppState.setGroups(await getAllGroups());
                const container = document.getElementById('groupsList');
                container.innerHTML = '';

                if (groups.length === 0) {
                    container.innerHTML = '<p style="color: #95A5A6;">No groups yet</p>';
                    return;
                }

                // Build hierarchical tree
                const tree = buildGroupsTree(groups, null);
                renderGroupsTree(container, tree, 0);
            } catch (err) {
                showStatus('Error loading groups: ' + err.message, 'error');
            }
        }

        function buildGroupsTree(allGroups, parentId) {
            return allGroups
                .filter(g => g.parentGroupId === parentId)
                .sort((a, b) => a.name.localeCompare(b.name))
                .map(group => ({
                    ...group,
                    children: buildGroupsTree(allGroups, group.id)
                }));
        }

        function renderGroupsTree(container, tree, level) {
            tree.forEach(group => {
                const div = document.createElement('div');
                div.className = `group-item level-${Math.min(level, 3)}`;

                const typeText = group.type ? `<span class="group-item-type">(${escapeHtml(group.type)})</span>` : '';

                div.innerHTML = `
                    <div class="group-item-info">
                        <span>${escapeHtml(group.name)}</span>
                        ${typeText}
                    </div>
                    <div class="group-item-actions">
                        <button class="btn-icon group-edit-btn" data-group-id="${group.id}" title="Edit">✎</button>
                        <button class="btn-icon group-delete-btn" data-group-id="${group.id}" title="Delete" style="color: #E74C3C;">×</button>
                    </div>
                `;
                container.appendChild(div);

                // Recursively render children
                if (group.children && group.children.length > 0) {
                    renderGroupsTree(container, group.children, level + 1);
                }
            });
        }

        async function populateGroupParentDropdown() {
            const select = document.getElementById('newGroupParent');
            const editId = document.getElementById('editGroupId').value;

            try {
                AppState.setGroups(await getAllGroups());

                select.innerHTML = '<option value="">None (Top Level)</option>';

                // If editing, exclude the group being edited and its descendants
                let excludeIds = [];
                if (editId) {
                    excludeIds = await getAllDescendantGroupIds(parseInt(editId));
                }

                // Build hierarchical options
                const tree = buildGroupsTree(groups, null);
                addGroupOptionsToSelect(select, tree, 0, excludeIds);
            } catch (err) {
                Debug.error('Error populating group parent dropdown:', err);
            }
        }

        function addGroupOptionsToSelect(select, tree, level, excludeIds = []) {
            tree.forEach(group => {
                // Skip excluded groups (the group being edited and its descendants)
                if (excludeIds.includes(group.id)) {
                    return;
                }
                const option = document.createElement('option');
                option.value = group.id;
                // Use increasing dashes to show hierarchy depth
                const prefix = level > 0 ? '–'.repeat(level) + ' ' : '';
                option.textContent = prefix + group.name;
                select.appendChild(option);

                // Recursively add children
                if (group.children && group.children.length > 0) {
                    addGroupOptionsToSelect(select, group.children, level + 1, excludeIds);
                }
            });
        }

        async function saveGroupChanges() {
            const name = document.getElementById('newGroupName').value.trim();
            const parentId = document.getElementById('newGroupParent').value;
            const type = document.getElementById('newGroupType').value.trim();
            const editId = document.getElementById('editGroupId').value;

            if (!name) {
                showStatus('Please enter a group name', 'error');
                return;
            }

            // Validate circular reference prevention
            if (editId && parentId) {
                const groupId = parseInt(editId);
                const parentGroupId = parseInt(parentId);

                // Use improved circular reference detection
                const allGroups = await getAllGroups();
                if (wouldCreateCircularReference(groupId, parentGroupId, allGroups)) {
                    showStatus('Error: This would create a circular reference in the group hierarchy', 'error');
                    return;
                }
            }

            try {
                const groupData = {
                    name,
                    parentGroupId: parentId ? parseInt(parentId) : null,
                    type: type || null
                };

                if (editId) {
                    groupData.id = parseInt(editId);
                }

                await saveGroup(groupData);

                // Clear group descendants cache since hierarchy changed
                AppState.groupDescendantsCache.clear();

                // Reset form
                cancelGroupEdit();

                await loadGroupsList();
                await populateGroupParentDropdown();

                // Update the main filter dropdowns
                await renderTable();

                showStatus(editId ? 'Group updated successfully' : 'Group added successfully');
            } catch (err) {
                showStatus('Error saving group: ' + err.message, 'error');
            }
        }

        async function editGroup(id) {
            const group = AppState.getGroupByIdSync(id);
            if (!group) return;

            // Set edit ID first
            document.getElementById('editGroupId').value = id;

            // Refresh parent dropdown (will now exclude this group and descendants)
            await populateGroupParentDropdown();

            // Populate form fields
            document.getElementById('newGroupName').value = group.name;
            document.getElementById('newGroupParent').value = group.parentGroupId || '';
            document.getElementById('newGroupType').value = group.type || '';

            // Update UI
            document.getElementById('groupFormTitle').textContent = 'Edit Group';
            document.getElementById('saveGroupBtn').textContent = 'Update Group';
            document.getElementById('cancelEditBtn').style.display = 'inline-block';

            // Scroll to top of modal
            document.querySelector('#manageGroupsModal .modal-content').scrollTop = 0;
        }

        function cancelGroupEdit() {
            // Clear form
            document.getElementById('newGroupName').value = '';
            document.getElementById('newGroupParent').value = '';
            document.getElementById('newGroupType').value = '';
            document.getElementById('editGroupId').value = '';

            // Reset UI
            document.getElementById('groupFormTitle').textContent = 'Add New Group';
            document.getElementById('saveGroupBtn').textContent = 'Add Group';
            document.getElementById('cancelEditBtn').style.display = 'none';
        }

        async function removeGroup(id) {
            const group = AppState.getGroupByIdSync(id);
            if (!group) return;

            // Check if group has children
            const children = await getGroupsByParent(id);
            if (children.length > 0) {
                showStatus('Cannot delete group with subgroups. Delete subgroups first.', 'error');
                return;
            }

            // Check if any funds use this group
            const funds = await getAllFunds();
            const fundsInGroup = funds.filter(f => f.groupId === id);
            if (fundsInGroup.length > 0) {
                if (!confirm(`This group contains ${fundsInGroup.length} fund(s). Deleting the group will remove the group assignment from these funds. Continue?`)) {
                    return;
                }

                // Remove groupId from affected funds
                for (const fund of fundsInGroup) {
                    fund.groupId = null;
                    await saveFundToDB(fund);
                }
            }

            try {
                await deleteGroup(id);

                // Clear cache
                AppState.groupDescendantsCache.clear();

                await loadGroupsList();
                await populateGroupParentDropdown();
                await renderTable();
                showStatus('Group deleted successfully', 'success');
            } catch (err) {
                showStatus('Error deleting group: ' + err.message, 'error');
            }
        }

        async function populateFundGroupDropdown(valueToSet = null) {
            const select = document.getElementById('fundGroup');

            try {
                AppState.setGroups(await getAllGroups());

                select.innerHTML = '<option value="">No Group</option>';

                // Build hierarchical options
                const tree = buildGroupsTree(groups, null);
                addGroupOptionsToSelect(select, tree, 0);

                // Set the value if provided
                if (valueToSet) {
                    select.value = valueToSet;
                }
            } catch (err) {
                Debug.error('Error populating fund group dropdown:', err);
            }
        }

        async function populateFundNamesDropdown(valueToSet = null) {
            const select = document.getElementById('fundName');
            const currentValue = valueToSet !== null ? valueToSet : select.value;

            try {
                const names = await getAllFundNames();
                Debug.log('Fund names from database:', names);
                AppState.setFundNames(new Set(names));

                select.innerHTML = '<option value="">Select a fund</option>';
                names.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    select.appendChild(option);
                });

                // Add option to create new fund
                const newOption = document.createElement('option');
                newOption.value = '__new__';
                newOption.textContent = '+ Add New Fund Name';
                select.appendChild(newOption);

                if (currentValue && currentValue !== '__new__') {
                    select.value = currentValue;
                }

                Debug.log('Dropdown populated with', names.length, 'fund names');

                // Handle new fund name creation - show inline input
                select.onchange = function() {
                    if (this.value === '__new__') {
                        document.getElementById('newFundNameContainer').style.display = 'block';
                        document.getElementById('newFundNameInline').value = '';
                        document.getElementById('newFundNameInline').focus();
                        this.style.display = 'none';
                    }
                };

                // Set up event listeners for inline fund name input (only once)
                if (!select.dataset.listenersAdded) {
                    select.dataset.listenersAdded = 'true';

                    document.getElementById('addNewFundNameBtn').onclick = async function() {
                        const input = document.getElementById('newFundNameInline');
                        const name = input.value.trim();

                        if (!name) {
                            showStatus('Please enter a fund name', 'error');
                            input.focus();
                            return;
                        }

                        if (name.length > 100) {
                            showStatus('Fund name too long (max 100 characters)', 'error');
                            input.focus();
                            return;
                        }

                        if (name.length < 2) {
                            showStatus('Fund name too short (min 2 characters)', 'error');
                            input.focus();
                            return;
                        }

                        if (!fundNames.has(name)) {
                            try {
                                await saveFundName(name);
                                fundNames.add(name);
                                fundNameData.set(name, { name: name, tags: [] });
                            } catch (err) {
                                showStatus('Error adding fund name: ' + err.message, 'error');
                                return;
                            }
                        }

                        // Hide inline input, show dropdown, populate and select new value
                        document.getElementById('newFundNameContainer').style.display = 'none';
                        select.style.display = '';
                        await populateFundNamesDropdown(name);
                        showStatus('Fund name added successfully');
                    };

                    document.getElementById('cancelNewFundNameBtn').onclick = function() {
                        document.getElementById('newFundNameContainer').style.display = 'none';
                        select.style.display = '';
                        select.value = '';
                    };

                    // Allow Enter key to add fund name
                    document.getElementById('newFundNameInline').onkeydown = function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            document.getElementById('addNewFundNameBtn').click();
                        } else if (e.key === 'Escape') {
                            document.getElementById('cancelNewFundNameBtn').click();
                        }
                    };
                }
            } catch (err) {
                Debug.error('Error populating fund names:', err);
            }
        }

        // ===========================
        // Import / Export
        // ===========================

        async function exportDatabase() {
            try {
                const funds = await getAllFunds();
                const fundNamesData = await getAllFundNameObjects(); // Get full objects with tags
                const groupsData = await getAllGroups();

                const exportData = {
                    funds,
                    fundNames: fundNamesData, // Export full objects instead of just names
                    groups: groupsData,
                    exportDate: new Date().toISOString()
                };

                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `pe-funds-export-${timestamp}.json`;

                if ('showSaveFilePicker' in window) {
                    try {
                        const handle = await window.showSaveFilePicker({
                            suggestedName: filename,
                            types: [{
                                description: 'JSON Files',
                                accept: { 'application/json': ['.json'] }
                            }]
                        });

                        const writable = await handle.createWritable();
                        await writable.write(blob);
                        await writable.close();

                        showStatus('Data exported successfully');
                        return;
                    } catch (err) {
                        if (err.name === 'AbortError') return;
                        throw err;
                    }
                }

                // Fallback
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showStatus('Data exported successfully');
                updateLastBackupTime();
            } catch (err) {
                showStatus('Error exporting data: ' + err.message, 'error');
                Debug.error('Error exporting data:', err);
            }
        }

        async function exportToCSV() {
            showLoading('Exporting to CSV...');
            try {
                // Get filtered and sorted data (same as what's displayed in the table)
                const funds = await getAllFunds();
                let filtered = applyCurrentFilters(funds);

                if (sortColumns.length > 0) {
                    filtered = sortData(filtered, sortColumns);
                }

                // Get cutoff date
                const cutoffDateValue = document.getElementById('cutoffDate').value;
                const cutoffDate = cutoffDateValue ? new Date(cutoffDateValue) : null;

                // Calculate metrics for each fund
                const fundsWithMetrics = filtered.map(fund => ({
                    ...fund,
                    metrics: calculateMetrics(fund, cutoffDate)
                }));

                // Create CSV header
                const headers = [
                    'Fund Name',
                    'Account Number',
                    'Vintage',
                    'Commitment',
                    'Total Contributions',
                    'Total Distributions',
                    'NAV',
                    'Investment Return',
                    'MOIC',
                    'IRR',
                    'Outstanding Commitment'
                ];

                // Use the sanitization function defined earlier (no need to redefine)

                // Helper to format number without $ symbol for CSV
                const formatNumber = (value) => {
                    const val = parseFloat(value);
                    if (!isFinite(val) || isNaN(val)) return '';
                    return val.toFixed(2);
                };

                // Create CSV rows with sanitization
                const rows = fundsWithMetrics.map(fund => {
                    const m = fund.metrics;
                    return [
                        escapeCSV(fund.fundName),
                        escapeCSV(fund.accountNumber),
                        escapeCSV(m.vintage || ''),
                        sanitizeForCSV(formatNumber(m.commitment)),
                        sanitizeForCSV(formatNumber(m.totalContributions)),
                        sanitizeForCSV(formatNumber(m.totalDistributions)),
                        sanitizeForCSV(formatNumber(m.nav)),
                        sanitizeForCSV(formatNumber(m.investmentReturn)),
                        sanitizeForCSV(m.moic !== null && isFinite(m.moic) ? m.moic.toFixed(2) : ''),
                        sanitizeForCSV(m.irr !== null ? (m.irr * 100).toFixed(2) : ''),
                        sanitizeForCSV(formatNumber(m.outstandingCommitment))
                    ].join(',');
                });

                // Combine header and rows
                const csv = [headers.join(','), ...rows].join('\n');

                // Create blob and download
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
                const filename = `pe-funds-export-${timestamp}.csv`;

                // Create download link
                const link = document.createElement('a');
                if (link.download !== undefined) {
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', filename);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                }

                showStatus('CSV exported successfully');
            } catch (err) {
                showStatus('Error exporting CSV: ' + err.message, 'error');
                Debug.error('Error exporting CSV:', err);
            } finally {
                hideLoading();
            }
        }

        function exportToPDF() {
            // Use the browser's print dialog to save as PDF
            window.print();
        }

        // Event delegation for dynamically created buttons and dropdown handling
        document.addEventListener('click', async function(event) {
            // Handle fund actions button
            if (event.target.classList.contains('fund-actions-btn')) {
                event.stopPropagation(); // Prevent immediate close
                const fundId = parseInt(event.target.getAttribute('data-fund-id'));
                await showActionModal(fundId, event.target);
                return;
            }

            // Close action dropdown when clicking outside
            const actionDropdown = document.getElementById('actionDropdown');
            if (actionDropdown && actionDropdown.classList.contains('show')) {
                if (!actionDropdown.contains(event.target)) {
                    closeActionModal();
                }
            }

            // Handle group edit button
            if (event.target.classList.contains('group-edit-btn')) {
                const groupId = parseInt(event.target.getAttribute('data-group-id'));
                await editGroup(groupId);
                return;
            }

            // Handle group delete button
            if (event.target.classList.contains('group-delete-btn')) {
                const groupId = parseInt(event.target.getAttribute('data-group-id'));
                await removeGroup(groupId);
                return;
            }

            // Close dropdown when clicking outside
            const dropdowns = document.querySelectorAll('.dropdown');
            dropdowns.forEach(dropdown => {
                if (!dropdown.contains(event.target)) {
                    const menu = dropdown.querySelector('.dropdown-menu');
                    if (menu) {
                        menu.classList.remove('show');
                    }
                }
            });
        });

        // Track changes in details modal
        document.addEventListener('input', function(event) {
            const detailsModal = document.getElementById('detailsModal');
            if (detailsModal && detailsModal.classList.contains('show')) {
                if (detailsModal.contains(event.target)) {
                    AppState.setUnsavedChanges(true);
                }
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', async function(event) {
            // Check if user is typing in an input field
            const isTyping = ['INPUT', 'TEXTAREA', 'SELECT'].includes(event.target.tagName);

            // ? key: Show keyboard shortcuts help (only if not typing)
            if (event.key === '?' && !isTyping) {
                event.preventDefault();
                showShortcutsModal();
                return;
            }

            // Escape key: Close sidebar or open modals
            if (event.key === 'Escape') {
                const sidebar = document.getElementById('sidebar');
                const shortcutsModal = document.getElementById('shortcutsModal');
                const detailsModal = document.getElementById('detailsModal');
                const actionDropdown = document.getElementById('actionDropdown');
                const fundModal = document.getElementById('fundModal');
                const manageFundsModal = document.getElementById('manageFundNamesModal');
                const editFundNameModal = document.getElementById('editFundNameModal');
                const manageGroupsModal = document.getElementById('manageGroupsModal');

                if (shortcutsModal && shortcutsModal.classList.contains('show')) {
                    closeShortcutsModal();
                } else if (sidebar && sidebar.classList.contains('show')) {
                    closeSidebar();
                } else if (detailsModal && detailsModal.classList.contains('show')) {
                    closeDetailsModal();
                } else if (actionDropdown && actionDropdown.classList.contains('show')) {
                    closeActionModal();
                } else if (fundModal && fundModal.classList.contains('show')) {
                    closeFundModal();
                } else if (editFundNameModal && editFundNameModal.classList.contains('show')) {
                    closeEditFundNameModal();
                } else if (manageFundsModal && manageFundsModal.classList.contains('show')) {
                    closeManageFundsModal();
                } else if (manageGroupsModal && manageGroupsModal.classList.contains('show')) {
                    closeManageGroupsModal();
                }
                return;
            }

            // Ctrl/Cmd+F: Focus search input
            if ((event.ctrlKey || event.metaKey) && event.key === 'f') {
                event.preventDefault();
                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    searchInput.focus();
                    searchInput.select();
                }
                return;
            }

            // Ctrl/Cmd+S: Save details if details modal is open
            if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                event.preventDefault();
                const detailsModal = document.getElementById('detailsModal');
                if (detailsModal && detailsModal.classList.contains('show')) {
                    await saveDetailsChanges();
                }
                return;
            }

            // Ctrl/Cmd+E: Export
            if ((event.ctrlKey || event.metaKey) && event.key === 'e') {
                event.preventDefault();
                await exportDatabase();
                return;
            }

            // Ctrl/Cmd+N: New investment
            if ((event.ctrlKey || event.metaKey) && event.key === 'n') {
                event.preventDefault();
                await showAddFundModal();
                return;
            }

            // Table row keyboard navigation
            const focusedRow = document.activeElement;
            const tbody = document.getElementById('fundsTableBody');
            if (focusedRow && focusedRow.tagName === 'TR' && focusedRow.hasAttribute('data-fund-id') && tbody && tbody.contains(focusedRow)) {
                const rows = Array.from(tbody.querySelectorAll('tr[data-fund-id]'));
                const currentIndex = rows.indexOf(focusedRow);

                // Arrow Down: Focus next row
                if (event.key === 'ArrowDown' && currentIndex < rows.length - 1) {
                    event.preventDefault();
                    rows[currentIndex + 1].focus();
                    return;
                }

                // Arrow Up: Focus previous row
                if (event.key === 'ArrowUp' && currentIndex > 0) {
                    event.preventDefault();
                    rows[currentIndex - 1].focus();
                    return;
                }

                // Enter: Open details modal for focused row
                if (event.key === 'Enter') {
                    event.preventDefault();
                    const fundId = parseInt(focusedRow.getAttribute('data-fund-id'));
                    if (fundId != null) {
                        openDetailsModal(fundId);
                    }
                    return;
                }

                // Space: Open action menu for focused row
                if (event.key === ' ') {
                    event.preventDefault();
                    const actionBtn = focusedRow.querySelector('.fund-actions-btn');
                    if (actionBtn) {
                        const fundId = parseInt(focusedRow.getAttribute('data-fund-id'));
                        await showActionModal(fundId, actionBtn);
                    }
                    return;
                }

                // Home: Jump to first row
                if (event.key === 'Home') {
                    event.preventDefault();
                    if (rows.length > 0) {
                        rows[0].focus();
                    }
                    return;
                }

                // End: Jump to last row
                if (event.key === 'End') {
                    event.preventDefault();
                    if (rows.length > 0) {
                        rows[rows.length - 1].focus();
                    }
                    return;
                }

                // Escape: Blur focused row
                if (event.key === 'Escape') {
                    event.preventDefault();
                    focusedRow.blur();
                    return;
                }

                // e: Quick edit
                if (event.key === 'e' || event.key === 'E') {
                    event.preventDefault();
                    const fundId = parseInt(focusedRow.getAttribute('data-fund-id'));
                    if (fundId != null) {
                        editFund(fundId);
                    }
                    return;
                }

                // Delete/Backspace: Delete fund (with confirmation)
                if (event.key === 'Delete' || event.key === 'Backspace') {
                    event.preventDefault();
                    const fundId = parseInt(focusedRow.getAttribute('data-fund-id'));
                    if (fundId != null) {
                        deleteFund(fundId);
                    }
                    return;
                }
            }
        });

        async function importDatabase(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file size using CONFIG constant
            if (file.size > CONFIG.MAX_FILE_SIZE) {
                showStatus(`File too large (${(file.size / 1024 / 1024).toFixed(2)}MB). Maximum size is ${CONFIG.MAX_FILE_SIZE / 1024 / 1024}MB.`, 'error');
                event.target.value = '';
                return;
            }

            showLoading('Importing data...');
            try {
                const text = await file.text();

                // Use safe JSON parse to prevent prototype pollution attacks
                const data = safeJSONParse(text);

                let imported = 0;
                const oldGroupIdToNew = {}; // Map old group IDs to new ones

                // Import groups first (since funds may reference them)
                if (data.groups && Array.isArray(data.groups)) {
                    // Validate import limits
                    if (data.groups.length > CONFIG.MAX_IMPORT_GROUPS) {
                        throw new Error(`Too many groups (${data.groups.length}). Maximum allowed is ${CONFIG.MAX_IMPORT_GROUPS}.`);
                    }
                    // Validate group hierarchy before importing
                    const groupIds = new Set(data.groups.map(g => g.id));

                    // Check for invalid parent references and circular dependencies
                    for (const group of data.groups) {
                        if (group.parentGroupId != null) {
                            // Check if parent exists in import data
                            if (!groupIds.has(group.parentGroupId)) {
                                Debug.warn(`Warning: Group "${group.name}" (ID ${group.id}) references non-existent parent ${group.parentGroupId}. Setting to top-level.`);
                                group.parentGroupId = null;
                            }

                            // Check for circular reference (direct self-reference)
                            if (group.id === group.parentGroupId) {
                                Debug.warn(`Warning: Group "${group.name}" (ID ${group.id}) has circular reference. Setting to top-level.`);
                                group.parentGroupId = null;
                            }
                        }
                    }

                    // Import groups sorted by hierarchy (parents before children)
                    const sortedGroups = [];
                    const addedIds = new Set();
                    let remainingGroups = [...data.groups];

                    // Keep adding groups whose parents have been added (or are null)
                    while (remainingGroups.length > 0) {
                        const initialLength = remainingGroups.length;

                        for (let i = remainingGroups.length - 1; i >= 0; i--) {
                            const group = remainingGroups[i];
                            if (group.parentGroupId == null || addedIds.has(group.parentGroupId)) {
                                sortedGroups.push(group);
                                addedIds.add(group.id);
                                remainingGroups.splice(i, 1);
                            }
                        }

                        // If no groups were added this iteration, we have circular dependencies
                        if (remainingGroups.length === initialLength) {
                            Debug.warn('Warning: Circular dependencies detected in remaining groups. Setting to top-level.');
                            remainingGroups.forEach(g => {
                                g.parentGroupId = null;
                                sortedGroups.push(g);
                            });
                            break;
                        }
                    }

                    // Import sorted groups
                    for (const group of sortedGroups) {
                        const oldId = group.id;
                        const { id, ...groupData } = group;

                        // Map parent ID to new ID if it was already imported
                        if (groupData.parentGroupId != null && oldGroupIdToNew[groupData.parentGroupId]) {
                            groupData.parentGroupId = oldGroupIdToNew[groupData.parentGroupId];
                        }

                        // Save group and get new ID
                        const newId = await saveGroup(groupData);
                        if (oldId != null && newId) {
                            oldGroupIdToNew[oldId] = newId;
                        }
                    }
                    // Reload groups cache
                    AppState.setGroups(await getAllGroups());
                }

                // Import fund names (now with tags and fund terms)
                if (data.fundNames && Array.isArray(data.fundNames)) {
                    // Validate import limits
                    if (data.fundNames.length > CONFIG.MAX_IMPORT_FUNDNAMES) {
                        throw new Error(`Too many fund names (${data.fundNames.length}). Maximum allowed is ${CONFIG.MAX_IMPORT_FUNDNAMES}.`);
                    }
                    for (const fundNameItem of data.fundNames) {
                        // Support both old format (string) and new format (object with tags/terms)
                        const fundNameObj = typeof fundNameItem === 'string'
                            ? { name: fundNameItem, tags: [] }
                            : {
                                name: fundNameItem.name,
                                tags: fundNameItem.tags || [],
                                firstCloseDate: fundNameItem.firstCloseDate || null,
                                finalCloseDate: fundNameItem.finalCloseDate || null,
                                investmentTermYears: fundNameItem.investmentTermYears || null
                            };

                        await saveFundName(fundNameObj);
                        fundNames.add(fundNameObj.name);
                        fundNameData.set(fundNameObj.name, fundNameObj);
                    }
                }

                // Import funds
                const fundsToImport = data.funds || data;
                if (!Array.isArray(fundsToImport)) {
                    throw new Error('Invalid format: expected array of funds');
                }

                // Validate import limits
                if (fundsToImport.length > CONFIG.MAX_IMPORT_FUNDS) {
                    throw new Error(`Too many funds (${fundsToImport.length}). Maximum allowed is ${CONFIG.MAX_IMPORT_FUNDS}.`);
                }

                // Collect unique fund names from imported funds (in case fundNames array is missing)
                const uniqueFundNames = new Set();
                fundsToImport.forEach(fund => {
                    if (fund.fundName && !fundNames.has(fund.fundName)) {
                        uniqueFundNames.add(fund.fundName);
                    }
                });

                // Save any missing fund names to database
                for (const name of uniqueFundNames) {
                    const fundNameObj = { name, tags: [] };
                    await saveFundName(fundNameObj);
                    fundNames.add(name);
                    fundNameData.set(name, fundNameObj);
                }

                const totalFunds = fundsToImport.length;
                const failedImports = [];
                const skippedDuplicates = [];

                // Build a set of existing fund keys for duplicate detection
                const existingFundKeys = new Set();
                currentFunds.forEach(f => {
                    const key = `${f.fundName}|${f.accountNumber}`.toLowerCase();
                    existingFundKeys.add(key);
                });

                for (let i = 0; i < fundsToImport.length; i++) {
                    const fund = fundsToImport[i];

                    // Check for duplicate (same fund name and account number)
                    const importKey = `${fund.fundName}|${fund.accountNumber}`.toLowerCase();
                    if (existingFundKeys.has(importKey)) {
                        skippedDuplicates.push({ index: i, name: fund.fundName, account: fund.accountNumber });
                        continue;
                    }

                    try {
                        // Add to existing keys to prevent duplicates within import batch
                        existingFundKeys.add(importKey);

                        // Normalize cash flows to ensure proper structure
                        const cashFlows = (fund.cashFlows || []).map(cf => ({
                            date: cf.date,
                            amount: parseCurrency(cf.amount),
                            type: cf.type || (cf.amount < 0 ? 'Contribution' : 'Distribution'),
                            affectsCommitment: cf.affectsCommitment !== undefined ? cf.affectsCommitment : true
                        }));

                        // Normalize monthly NAV
                        const monthlyNav = (fund.monthlyNav || []).map(nav => ({
                            date: nav.date,
                            amount: parseCurrency(nav.amount)
                        }));

                        // Map old groupId to new groupId if applicable
                        let groupId = null;
                        if (fund.groupId && oldGroupIdToNew[fund.groupId]) {
                            groupId = oldGroupIdToNew[fund.groupId];
                        }

                        const fundData = {
                            fundName: fund.fundName,
                            accountNumber: fund.accountNumber,
                            groupId: groupId,
                            commitment: parseCurrency(fund.commitment),
                            cashFlows: cashFlows,
                            monthlyNav: monthlyNav,
                            timestamp: fund.timestamp || new Date().toISOString()
                        };

                        await saveFundToDB(fundData);
                        imported++;
                    } catch (fundErr) {
                        Debug.error(`Error importing fund at index ${i}:`, fundErr, fund);
                        failedImports.push({ index: i, name: fund.fundName || fund.accountNumber || 'Unknown', error: fundErr.message });
                    }
                }

                await renderTable();

                if (failedImports.length > 0 || skippedDuplicates.length > 0) {
                    const messages = [];
                    if (imported > 0) messages.push(`${imported} imported`);
                    if (skippedDuplicates.length > 0) {
                        messages.push(`${skippedDuplicates.length} duplicates skipped`);
                        Debug.log('Skipped duplicates:', skippedDuplicates);
                    }
                    if (failedImports.length > 0) {
                        messages.push(`${failedImports.length} failed`);
                        Debug.error('Failed imports:', failedImports);
                    }
                    const status = failedImports.length > 0 ? 'error' : 'success';
                    showStatus(`Import complete: ${messages.join(', ')} (see console for details)`, status);
                    if (failedImports.length === 0) {
                        event.target.value = '';
                    }
                } else {
                    showStatus(`Successfully imported ${imported} fund(s)`);
                    event.target.value = '';
                }
            } catch (err) {
                showStatus('Error importing data: ' + err.message, 'error');
                Debug.error('Error importing data:', err);
                // Don't clear input on error so user can retry
            } finally {
                hideLoading();
            }
        }

        // ===========================
        // Column Resizing
        // ===========================

        function initializeColumnResizing() {
            const table = document.getElementById('fundsTable');
            const thead = table.querySelector('thead');
            const ths = thead.querySelectorAll('th');

            // Add resizer to each column header except the last one (Actions column)
            ths.forEach((th, index) => {
                if (index < ths.length - 1) { // Skip the last column
                    th.classList.add('resizable');

                    // Create resizer element
                    const resizer = document.createElement('div');
                    resizer.className = 'resizer';
                    th.appendChild(resizer);

                    // Prevent click events on resizer from triggering sort
                    resizer.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                    });

                    // Variables for resizing
                    let startX, startWidth;

                    resizer.addEventListener('mousedown', (e) => {
                        e.stopPropagation(); // Prevent sort trigger
                        e.preventDefault(); // Prevent text selection
                        startX = e.pageX;
                        startWidth = th.offsetWidth;

                        isResizingColumn = true;
                        th.classList.add('resizing');
                        document.body.style.cursor = 'col-resize';
                        document.body.style.userSelect = 'none';

                        const onMouseMove = (e) => {
                            const diff = e.pageX - startX;
                            const newWidth = Math.max(CONFIG.MIN_COLUMN_WIDTH, startWidth + diff);
                            th.style.width = newWidth + 'px';
                            th.style.minWidth = newWidth + 'px';
                            th.style.maxWidth = newWidth + 'px';

                            // Also set width on corresponding td elements
                            const columnIndex = Array.from(ths).indexOf(th);
                            const tds = table.querySelectorAll(`tbody tr td:nth-child(${columnIndex + 1})`);
                            tds.forEach(td => {
                                td.style.width = newWidth + 'px';
                                td.style.minWidth = newWidth + 'px';
                                td.style.maxWidth = newWidth + 'px';
                            });

                            // Save to localStorage
                            saveColumnWidth(columnIndex, newWidth);
                        };

                        // Declare cleanup early so onMouseUp can reference it
                        let cleanup;

                        const onMouseUp = () => {
                            th.classList.remove('resizing');
                            document.body.style.cursor = '';
                            document.body.style.userSelect = '';
                            document.removeEventListener('mousemove', onMouseMove);
                            document.removeEventListener('mouseup', onMouseUp);
                            window.removeEventListener('blur', cleanup); // Clean up blur listener
                            // Reset flag after a short delay so click handler can check it
                            setTimeout(() => { isResizingColumn = false; }, 50);
                        };

                        cleanup = () => {
                            // Ensure cleanup happens even if mouse leaves window
                            if (th.classList.contains('resizing')) {
                                onMouseUp();
                            }
                        };

                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                        window.addEventListener('blur', cleanup); // Handle tab switch/window blur
                    });
                }
            });

            // Restore saved column widths
            restoreColumnWidths();
        }

        /**
         * Save column width to localStorage
         * @param {number} columnIndex - Column index
         * @param {number} width - Column width in pixels
         */
        function saveColumnWidth(columnIndex, width) {
            const savedWidths = Storage.get(CONFIG.STORAGE_COLUMN_WIDTHS, {});
            savedWidths[columnIndex] = width;
            Storage.set(CONFIG.STORAGE_COLUMN_WIDTHS, savedWidths);
        }

        /**
         * Restore saved column widths from localStorage
         */
        function restoreColumnWidths() {
            const savedWidths = Storage.get(CONFIG.STORAGE_COLUMN_WIDTHS, {});
            const table = document.getElementById('fundsTable');
            const ths = table.querySelectorAll('thead th');

            Object.keys(savedWidths).forEach(columnIndex => {
                const width = savedWidths[columnIndex];
                const th = ths[columnIndex];
                if (th) {
                    th.style.width = width + 'px';
                    th.style.minWidth = width + 'px';
                    th.style.maxWidth = width + 'px';

                    // Also set width on corresponding td elements
                    const tds = table.querySelectorAll(`tbody tr td:nth-child(${parseInt(columnIndex) + 1})`);
                    tds.forEach(td => {
                        td.style.width = width + 'px';
                        td.style.minWidth = width + 'px';
                        td.style.maxWidth = width + 'px';
                    });
                }
            });
        }

        // ===========================
        // Backup Warning & Reminders
        // ===========================

        /**
         * Check if backup warning should be shown
         */
        function shouldShowBackupWarning() {
            const warningShown = Storage.get(CONFIG.STORAGE_BACKUP_WARNING, false);
            const lastBackup = Storage.get(CONFIG.STORAGE_LAST_BACKUP, null);

            // Always show if never shown
            if (!warningShown) return true;

            // Show if more than 30 days since last backup
            if (lastBackup) {
                const daysSinceBackup = (Date.now() - new Date(lastBackup).getTime()) / (1000 * 60 * 60 * 24);
                if (daysSinceBackup > 30) return true;
            }

            return false;
        }

        /**
         * Show backup warning modal
         */
        function showBackupWarning() {
            const modal = document.getElementById('backupWarningModal');
            if (modal) {
                modal.classList.add('show');
            }
        }

        /**
         * Close backup warning modal
         */
        function closeBackupWarning() {
            const modal = document.getElementById('backupWarningModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        /**
         * Check backup reminder after data changes
         */
        function checkBackupReminder() {
            const lastBackup = Storage.get(CONFIG.STORAGE_LAST_BACKUP, null);
            if (lastBackup) {
                const daysSinceBackup = (Date.now() - new Date(lastBackup).getTime()) / (1000 * 60 * 60 * 24);
                if (daysSinceBackup > 7) {
                    // Show subtle reminder in sidebar
                    const sidebar = document.getElementById('sidebar');
                    if (sidebar && !document.getElementById('backupReminder')) {
                        const reminder = document.createElement('div');
                        reminder.id = 'backupReminder';
                        reminder.style.cssText = 'padding: 10px 20px; background: #FFF3CD; color: #856404; font-size: 12px; border-top: 1px solid #FFEAA7;';
                        reminder.textContent = `⚠️ ${Math.floor(daysSinceBackup)} days since last backup`;
                        sidebar.appendChild(reminder);
                    }
                }
            }
        }

        /**
         * Update last backup timestamp
         */
        function updateLastBackupTime() {
            Storage.set(CONFIG.STORAGE_LAST_BACKUP, new Date().toISOString());
        }

        // ===========================
        // Initialization
        // ===========================

        /**
         * Event listener setup organized by feature area
         */
        const EventListeners = {
            /** Filter controls and toolbar */
            setupFilters() {
                document.getElementById('groupFilter').addEventListener('change', applyFilters);
                document.getElementById('fundFilter').addEventListener('change', applyFilters);
                document.getElementById('accountFilter').addEventListener('change', applyFilters);
                document.getElementById('vintageFilter').addEventListener('change', applyFilters);
                document.getElementById('searchInput').addEventListener('input', applyFiltersDebounced);
                document.getElementById('cutoffDate').addEventListener('change', applyFilters);
                document.getElementById('timelineHeader').addEventListener('click', toggleTimelinePanel);
                document.getElementById('toggleSidebarBtn').addEventListener('click', toggleSidebar);
            },

            /** Table header sorting with column resizing awareness */
            setupTableSorting() {
                const thead = document.querySelector('#fundsTable thead');
                thead.addEventListener('mousedown', (e) => {
                    lastMousedownOnResizer = e.target.closest('.resizer') !== null;
                });
                thead.addEventListener('click', (e) => {
                    if (lastMousedownOnResizer || isResizingColumn || e.target.closest('.resizer')) {
                        lastMousedownOnResizer = false;
                        return;
                    }
                    lastMousedownOnResizer = false;
                    const th = e.target.closest('th[data-sort]');
                    if (th) {
                        sortTable(th.getAttribute('data-sort'));
                    }
                });
            },

            /** Fund add/edit modal */
            setupFundModal() {
                document.getElementById('closeFundModalBtn').addEventListener('click', closeFundModal);
                document.getElementById('cancelFundModalBtn').addEventListener('click', closeFundModal);
                document.getElementById('fundForm').addEventListener('submit', saveFund);
            },

            /** Action dropdown (edit, duplicate, details, delete) */
            setupActionDropdown() {
                const actions = {
                    'actionEdit': editFundFromAction,
                    'actionDuplicate': duplicateFundFromAction,
                    'actionViewDetails': showDetailsFromAction,
                    'actionDelete': deleteFundFromAction
                };
                Object.entries(actions).forEach(([id, handler]) => {
                    document.getElementById(id).addEventListener('click', (e) => {
                        e.preventDefault();
                        handler();
                    });
                });
            },

            /** Fund names management modal */
            setupFundNamesModal() {
                document.getElementById('closeManageFundsModalBtn').addEventListener('click', closeManageFundsModal);
                document.getElementById('closeManageFundsModal2Btn').addEventListener('click', closeManageFundsModal);
                document.getElementById('addNewFundNameBtn').addEventListener('click', addNewFundName);
                document.getElementById('closeEditFundNameModalBtn').addEventListener('click', closeEditFundNameModal);
                document.getElementById('saveEditedFundNameBtn').addEventListener('click', saveEditedFundName);
                document.getElementById('cancelEditFundNameBtn').addEventListener('click', closeEditFundNameModal);
            },

            /** Groups management modal */
            setupGroupsModal() {
                document.getElementById('closeManageGroupsModal2Btn').addEventListener('click', closeManageGroupsModal);
                document.getElementById('closeManageGroupsModalBtn').addEventListener('click', closeManageGroupsModal);
                document.getElementById('saveGroupBtn').addEventListener('click', saveGroupChanges);
                document.getElementById('cancelEditBtn').addEventListener('click', cancelGroupEdit);
            },

            /** Details modal with cash flows and NAV tables */
            setupDetailsModal() {
                document.getElementById('closeDetailsModalBtn').addEventListener('click', closeDetailsModal);
                document.getElementById('cancelDetailsModalBtn').addEventListener('click', closeDetailsModal);
                document.getElementById('addCashFlowRowBtn').addEventListener('click', addCashFlowRow);
                document.getElementById('addNavRowBtn').addEventListener('click', addNavRow);
                document.getElementById('saveDetailsChangesBtn').addEventListener('click', saveDetailsChanges);

                // Event delegation for dynamically created rows
                document.getElementById('cashFlowsTable').addEventListener('click', (e) => {
                    const btn = e.target.closest('[data-action="deleteCashFlow"]');
                    if (btn) deleteCashFlowRow(btn);
                });
                document.getElementById('navTable').addEventListener('click', (e) => {
                    const btn = e.target.closest('[data-action="deleteNav"]');
                    if (btn) deleteNavRow(btn);
                });
                document.getElementById('editFundTagsContainer').addEventListener('click', (e) => {
                    const btn = e.target.closest('[data-action="removeTag"]');
                    if (btn) removeEditFundTag(btn);
                });
            },

            /** Backup warning modal */
            setupBackupWarning() {
                document.getElementById('closeBackupWarningBtn').addEventListener('click', closeBackupWarning);
                document.getElementById('exportNowBtn').addEventListener('click', async () => {
                    closeBackupWarning();
                    await exportDatabase();
                    updateLastBackupTime();
                });
                document.getElementById('remindLaterBtn').addEventListener('click', () => {
                    if (document.getElementById('dontShowBackupWarning').checked) {
                        Storage.set(CONFIG.STORAGE_BACKUP_WARNING, true);
                    }
                    closeBackupWarning();
                });
            },

            /** Sidebar and its menu items */
            setupSidebar() {
                document.getElementById('sidebarOverlay').addEventListener('click', closeSidebar);
                document.getElementById('closeSidebarBtn').addEventListener('click', closeSidebar);
                document.getElementById('sidebarShowTagsCheckbox').addEventListener('change', toggleTagsDisplay);
                document.getElementById('sidebarDarkModeCheckbox').addEventListener('change', toggleDarkMode);

                // Menu items with sidebar close behavior
                const menuItems = {
                    'sidebarNewInvestment': showAddFundModal,
                    'sidebarManageFunds': showManageFundsModal,
                    'sidebarManageGroups': showManageGroupsModal,
                    'sidebarExportCSV': exportToCSV,
                    'sidebarExportJSON': exportDatabase,
                    'sidebarExportPDF': exportToPDF
                };
                Object.entries(menuItems).forEach(([id, handler]) => {
                    document.getElementById(id).addEventListener('click', (e) => {
                        e.preventDefault();
                        closeSidebar();
                        handler();
                    });
                });

                document.getElementById('sidebarImportFile').addEventListener('change', async (e) => {
                    await importDatabase(e);
                    closeSidebar();
                });
            },

            /** Keyboard shortcuts modal */
            setupShortcutsModal() {
                document.getElementById('closeShortcutsModalBtn').addEventListener('click', closeShortcutsModal);
                document.getElementById('closeShortcutsModal2Btn').addEventListener('click', closeShortcutsModal);
            },

            /** Initialize all event listeners */
            init() {
                this.setupFilters();
                this.setupTableSorting();
                this.setupFundModal();
                this.setupActionDropdown();
                this.setupFundNamesModal();
                this.setupGroupsModal();
                this.setupDetailsModal();
                this.setupBackupWarning();
                this.setupSidebar();
                this.setupShortcutsModal();
            }
        };

        /**
         * Initialize all event listeners (legacy wrapper)
         */
        function initializeEventListeners() {
            EventListeners.init();
        }

        function setControlsEnabled(enabled) {
            const buttons = document.querySelectorAll('button');
            const inputs = document.querySelectorAll('input, select, textarea');

            inputs.forEach(input => input.disabled = !enabled);
            buttons.forEach(button => button.disabled = !enabled);
        }

        async function init() {
            showLoading('Initializing application...');
            try {
                setControlsEnabled(false);

                await initDB();

                // Load fund name objects (with tags)
                const fundNameObjects = await getAllFundNameObjects();
                AppState.setFundNames(new Set(fundNameObjects.map(obj => obj.name)));
                AppState.setFundNameData(new Map(fundNameObjects.map(obj => [obj.name, obj])));

                // Load groups
                AppState.setGroups(await getAllGroups());

                // Set default cutoff date to latest quarter end
                const quarterEnd = getLatestQuarterEnd();
                document.getElementById('cutoffDate').value = quarterEnd.toISOString().split('T')[0];

                // Restore tag display preference from localStorage (default: true)
                const showTags = Storage.get('showTags', true);
                document.getElementById('sidebarShowTagsCheckbox').checked = showTags;

                // Initialize dark mode from saved preference
                initializeDarkMode();

                // Initialize timeline panel state (default to collapsed)
                const timelinePanelExpanded = Storage.get('timelinePanelExpanded', false);
                if (timelinePanelExpanded) {
                    document.getElementById('timelinePanel').classList.add('expanded');
                }

                await renderTable();

                // Initialize column resizing
                initializeColumnResizing();

                // Initialize event listeners
                initializeEventListeners();

                setControlsEnabled(true);

                // Show backup warning if needed
                setTimeout(() => {
                    if (shouldShowBackupWarning()) {
                        showBackupWarning();
                    }
                }, 1000); // Delay to not interfere with initial load

                Debug.log('PE Fund Manager initialized successfully');
            } catch (err) {
                showStatus('Error initializing application: ' + err.message, 'error');
                Debug.error('Error initializing application:', err);
            } finally {
                hideLoading();
            }
        }

            // Expose functions needed by inline onclick handlers in dynamic HTML
            window.showAddFundModal = showAddFundModal;
            window.resetFilters = resetFilters;
            window.fillCashFlowsExample = fillCashFlowsExample;
            window.fillNavExample = fillNavExample;

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
        })();
    </script>
</body>
</html>
