# Phase 3 Report — State, Persistence & Data Integrity

**Date:** 2026-01-22
**Files Reviewed:**
- `src/core/state.ts` (177 lines)
- `src/core/db.ts` (768 lines)
- `src/app/import.ts` (581 lines)
- `src/app/export.ts` (193 lines)

---

## Data Integrity Risk Register

| ID | File:Line | Severity | Issue | Impact |
|----|-----------|----------|-------|--------|
| DI-001 | db.ts:225-269 | **MEDIUM** | Non-atomic read-then-write in saveFundToDB | Audit log may capture stale state |
| DI-002 | import.ts:358-407 | **HIGH** | Partial import commits on failure | Inconsistent data state after failed import |
| DI-003 | db.ts:314-321 | **MEDIUM** | Date normalization fallback uses unsafe Date() | Timezone issues in legacy data |
| DI-004 | import.ts:20 | **LOW** | Module-level pendingImportData | Race condition if user triggers multiple imports |
| DI-005 | db.ts:566-600 | **MEDIUM** | clearAllData not in single transaction | Partial clear possible on failure |
| DI-006 | state.ts:66-68 | **LOW** | setFunds replaces entire array | No change detection, may lose unsaved edits |

---

## Issue Details

### DI-001: Non-Atomic Read-Then-Write (MEDIUM)

**Location:** `src/core/db.ts:225-269`

**Problem:** `saveFundToDB` reads the previous fund state in one transaction, then writes in a separate transaction:
```typescript
// Transaction 1: Read previous state
const getRequest = db.transaction([CONFIG.FUNDS_STORE], 'readonly')
  .objectStore(CONFIG.FUNDS_STORE).get(fundData.id!);

// ... then later ...

// Transaction 2: Write new state
const tx = db!.transaction([CONFIG.FUNDS_STORE], 'readwrite');
```

**Risk:** If another operation modifies the fund between read and write (unlikely in SPA but possible with multiple tabs), the audit log will record incorrect "previous" state.

**Remediation:** Combine get and put in a single `readwrite` transaction, or accept the minor audit inconsistency risk given SPA context.

---

### DI-002: Partial Import on Failure (HIGH)

**Location:** `src/app/import.ts:358-407`

**Problem:** The import loop saves funds one-by-one. If fund #50 of 100 fails validation, funds #1-49 are already committed to IndexedDB.

```typescript
for (let i = 0; i < fundsToImport.length; i++) {
  // ... validation ...
  await saveFundToDB(fundData);  // Already committed if later funds fail
  imported++;
}
```

**Impact:** User may end up with partially imported data that's hard to identify and clean up.

**Remediation Options:**
1. **Batch validation first:** Validate all funds before saving any
2. **Track imported IDs:** On failure, offer to roll back imported records
3. **Transaction batching:** Use IndexedDB transactions to batch multiple writes (complex)

---

### DI-003: Date Normalization Fallback (MEDIUM)

**Location:** `src/core/db.ts:314-321`

**Problem:** The `normalizeDate` fallback uses `new Date(dateStr)` which has timezone issues per CLAUDE.md:

```typescript
const date = new Date(dateStr);  // Timezone unsafe
if (!isNaN(date.getTime())) {
  return `${year}-${month}-${day}`;  // May be off by one day
}
```

**Impact:** Legacy data with unusual date formats may be normalized to wrong dates (off by one day at timezone boundaries).

**Remediation:** Use explicit UTC parsing or avoid the Date constructor fallback entirely:
```typescript
// Instead of new Date(), return original and let validation catch it
console.warn('Unparseable date, preserving original:', dateInput);
return dateStr;
```

---

### DI-004: Module-Level Import State (LOW)

**Location:** `src/app/import.ts:20`

**Problem:** `pendingImportData` is module-level state. If user rapidly selects files or triggers imports, state could be corrupted.

```typescript
let pendingImportData: any = null;  // Shared across all calls
```

**Impact:** Low risk in practice (UI prevents rapid double-import), but not defensive.

**Remediation:** Clear `pendingImportData` at start of `handleImportFileSelect`, or use a state machine pattern.

---

### DI-005: clearAllData Multi-Store Operation (MEDIUM)

**Location:** `src/core/db.ts:566-600`

**Problem:** `clearAllData` clears three stores in one transaction but tracks completion with a counter. If one store fails, the transaction should roll back, but the error handling may leave inconsistent state.

**Actual behavior:** Transaction-level rollback should work correctly. The counter pattern is verbose but functionally correct.

**Minor Issue:** The audit log entry is written after the clear completes, using a NEW transaction. If audit logging fails, the clear still happened with no record.

**Remediation:** Log audit entry within the same transaction if possible, or accept that audit may miss failed operations.

---

### DI-006: setFunds Replaces Entire Array (LOW)

**Location:** `src/core/state.ts:66-68`

**Problem:** `setFunds` replaces the entire funds array. If a user has unsaved edits in a modal while a background refresh occurs, their edits reference a stale object.

```typescript
setFunds(funds: Fund[]): void {
  this.currentFunds = funds;  // Replaces entire array
}
```

**Impact:** Low because UI typically calls setFunds only on explicit load/refresh, but could cause data loss if combined with aggressive auto-refresh.

**Remediation:** Document that setFunds should not be called while modals are open, or implement change detection.

---

## Positive Findings

### Validation Before Save ✓
`saveFundToDB` validates data before committing:
```typescript
const validation = validateFund(fundData);
if (!validation.valid) {
  reject(new Error(...));
}
```
This prevents corrupt data from entering the database.

### Prototype Pollution Protection ✓
Import uses `safeJSONParse` and `sanitizeObject` to block `__proto__`, `constructor`, `prototype` keys.

### Audit Logging ✓
Fund modifications are logged to an audit store with timestamps, operation types, and change summaries.

### Data Normalization ✓
`normalizeFund` handles legacy data formats (string amounts, various date formats, case-insensitive types).

### Duplicate Detection ✓
Import checks for existing `fundName|accountNumber` combinations before importing.

### Circular Reference Detection ✓
Group import detects circular parent references and moves orphaned groups to root level.

### CSV Injection Protection ✓
Export sanitizes values starting with `=`, `+`, `-`, `@`, `\t`, `\r` to prevent formula injection.

---

## Failure Mode Analysis

| Scenario | Current Behavior | Risk Level |
|----------|------------------|------------|
| Browser closes during IndexedDB write | Transaction rolls back, data intact | LOW |
| Import of 1000 funds, #500 fails | First 499 committed, no easy rollback | HIGH |
| Two browser tabs modify same fund | Last write wins, no conflict detection | MEDIUM |
| clearAllData fails mid-operation | Transaction rolls back | LOW |
| Audit store full/unavailable | Logs to console, operation continues | LOW |
| Invalid date in import | Normalized to best guess or preserved | MEDIUM |

---

## Recommended Safeguards

1. **Pre-validation pass for imports:** Validate all records before saving any
2. **Import transaction wrapper:** Wrap entire import in try/catch with rollback tracking
3. **Tab coordination:** Consider BroadcastChannel API for multi-tab state sync (future)
4. **Backup before destructive operations:** Auto-export before clearAllData

---

## Summary

**Overall Assessment:** The persistence layer is well-designed with good validation, normalization, and audit logging. The main risk is partial imports leaving inconsistent state.

**Critical Issue:** DI-002 (partial import) should be addressed to prevent data inconsistency.

**Recommended Priority:**
1. Add pre-validation pass to import flow
2. Consider date normalization fallback safety
3. Document multi-tab limitations

---

**Next:** Phase 4 — Security & Performance
